{"version":3,"file":"components-DLh8nZLf.js","sources":["../../../../../node_modules/.pnpm/react-router-dom@6.23.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-router-dom/dist/index.js","../../../../../node_modules/.pnpm/turbo-stream@2.2.0/node_modules/turbo-stream/dist/turbo-stream.mjs","../../../../../node_modules/.pnpm/@remix-run+server-runtime@2.9.2_typescript@5.4.5/node_modules/@remix-run/server-runtime/dist/esm/single-fetch.js","../../../../../node_modules/.pnpm/@remix-run+react@2.9.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.4.5/node_modules/@remix-run/react/dist/esm/_virtual/_rollupPluginBabelHelpers.js","../../../../../node_modules/.pnpm/@remix-run+react@2.9.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.4.5/node_modules/@remix-run/react/dist/esm/invariant.js","../../../../../node_modules/.pnpm/@remix-run+react@2.9.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.4.5/node_modules/@remix-run/react/dist/esm/routeModules.js","../../../../../node_modules/.pnpm/@remix-run+react@2.9.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.4.5/node_modules/@remix-run/react/dist/esm/links.js","../../../../../node_modules/.pnpm/@remix-run+react@2.9.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.4.5/node_modules/@remix-run/react/dist/esm/markup.js","../../../../../node_modules/.pnpm/@remix-run+react@2.9.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.4.5/node_modules/@remix-run/react/dist/esm/data.js","../../../../../node_modules/.pnpm/@remix-run+react@2.9.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.4.5/node_modules/@remix-run/react/dist/esm/single-fetch.js","../../../../../node_modules/.pnpm/@remix-run+react@2.9.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.4.5/node_modules/@remix-run/react/dist/esm/components.js"],"sourcesContent":["/**\n * React Router DOM v6.23.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { UNSAFE_mapRouteProperties, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, Router, UNSAFE_useRoutesImpl, UNSAFE_NavigationContext, useHref, useResolvedPath, useLocation, useNavigate, createPath, UNSAFE_useRouteId, UNSAFE_RouteContext, useMatches, useNavigation, useBlocker } from 'react-router';\nexport { AbortedDeferredError, Await, MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, Routes, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_LocationContext, UNSAFE_NavigationContext, UNSAFE_RouteContext, UNSAFE_useRouteId, createMemoryRouter, createPath, createRoutesFromChildren, createRoutesFromElements, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, redirectDocument, renderMatches, resolvePath, useActionData, useAsyncError, useAsyncValue, useBlocker, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes } from 'react-router';\nimport { stripBasename, UNSAFE_warning, createRouter, createBrowserHistory, createHashHistory, UNSAFE_ErrorResponseImpl, UNSAFE_invariant, joinPaths, IDLE_FETCHER, matchPath } from '@remix-run/router';\nexport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && (\n  // Ignore everything but left clicks\n  !target || target === \"_self\") &&\n  // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\n  ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n    // web extensions. Relevant Bugzilla tickets:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach(value => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(document.createElement(\"form\"),\n      // @ts-expect-error if FormData supports the submitter parameter, this will throw\n      0);\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n    }\n    // <button>/<input type=\"submit\"> may override attributes of <form>\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    // Build a FormData object populated from a form and submitter\n    formData = new FormData(form, target);\n    // If this browser doesn't support the `FormData(el, submitter)` format,\n    // then tack on the submitter value at the end.  This is a lightweight\n    // solution that is not 100% spec compliant.  For complete support in older\n    // browsers, consider using the `formdata-submitter-polyfill` package\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === \"image\") {\n        let prefix = name ? name + \".\" : \"\";\n        formData.append(prefix + \"x\", \"0\");\n        formData.append(prefix + \"y\", \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  // Send body for <Form encType=\"text/plain\" so we encode it into text\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = undefined;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\n\nconst _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"],\n  _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"],\n  _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\n// HEY YOU! DON'T TOUCH THIS VARIABLE!\n//\n// It is replaced with the proper version at build time via a babel plugin in\n// the rollup config.\n//\n// Export a global property onto the window for React Router detection by the\n// Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`\n// to detect and properly classify live websites as being built with React Router:\n// https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json\nconst REACT_ROUTER_VERSION = \"6\";\ntry {\n  window.__reactRouterVersion = REACT_ROUTER_VERSION;\n} catch (e) {\n  // no-op\n}\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createBrowserHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties,\n    unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties,\n    unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don't serialize SSR stack traces for security reasons\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\n        // because we don't serialize SSR stack traces for security reasons\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nconst ViewTransitionContext = /*#__PURE__*/React.createContext({\n  isTransitioning: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  ViewTransitionContext.displayName = \"ViewTransition\";\n}\nconst FetchersContext = /*#__PURE__*/React.createContext(new Map());\nif (process.env.NODE_ENV !== \"production\") {\n  FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\nconst FLUSH_SYNC = \"flushSync\";\nconst flushSyncImpl = ReactDOM[FLUSH_SYNC];\nconst USE_ID = \"useId\";\nconst useIdImpl = React[USE_ID];\nfunction startTransitionSafe(cb) {\n  if (startTransitionImpl) {\n    startTransitionImpl(cb);\n  } else {\n    cb();\n  }\n}\nfunction flushSyncSafe(cb) {\n  if (flushSyncImpl) {\n    flushSyncImpl(cb);\n  } else {\n    cb();\n  }\n}\nclass Deferred {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = value => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = reason => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React.useState(router.state);\n  let [pendingState, setPendingState] = React.useState();\n  let [vtContext, setVtContext] = React.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = React.useState();\n  let [transition, setTransition] = React.useState();\n  let [interruption, setInterruption] = React.useState();\n  let fetcherData = React.useRef(new Map());\n  let {\n    v7_startTransition\n  } = future || {};\n  let optInStartTransition = React.useCallback(cb => {\n    if (v7_startTransition) {\n      startTransitionSafe(cb);\n    } else {\n      cb();\n    }\n  }, [v7_startTransition]);\n  let setState = React.useCallback((newState, _ref2) => {\n    let {\n      deletedFetchers,\n      unstable_flushSync: flushSync,\n      unstable_viewTransitionOpts: viewTransitionOpts\n    } = _ref2;\n    deletedFetchers.forEach(key => fetcherData.current.delete(key));\n    newState.fetchers.forEach((fetcher, key) => {\n      if (fetcher.data !== undefined) {\n        fetcherData.current.set(key, fetcher.data);\n      }\n    });\n    let isViewTransitionUnavailable = router.window == null || router.window.document == null || typeof router.window.document.startViewTransition !== \"function\";\n    // If this isn't a view transition or it's not available in this browser,\n    // just update and be done with it\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\n      if (flushSync) {\n        flushSyncSafe(() => setStateImpl(newState));\n      } else {\n        optInStartTransition(() => setStateImpl(newState));\n      }\n      return;\n    }\n    // flushSync + startViewTransition\n    if (flushSync) {\n      // Flush through the context to mark DOM elements as transition=ing\n      flushSyncSafe(() => {\n        // Cancel any pending transitions\n        if (transition) {\n          renderDfd && renderDfd.resolve();\n          transition.skipTransition();\n        }\n        setVtContext({\n          isTransitioning: true,\n          flushSync: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      });\n      // Update the DOM\n      let t = router.window.document.startViewTransition(() => {\n        flushSyncSafe(() => setStateImpl(newState));\n      });\n      // Clean up after the animation completes\n      t.finished.finally(() => {\n        flushSyncSafe(() => {\n          setRenderDfd(undefined);\n          setTransition(undefined);\n          setPendingState(undefined);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n      });\n      flushSyncSafe(() => setTransition(t));\n      return;\n    }\n    // startTransition + startViewTransition\n    if (transition) {\n      // Interrupting an in-progress transition, cancel and let everything flush\n      // out, and then kick off a new transition from the interruption state\n      renderDfd && renderDfd.resolve();\n      transition.skipTransition();\n      setInterruption({\n        state: newState,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    } else {\n      // Completed navigation update with opted-in view transitions, let 'er rip\n      setPendingState(newState);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    }\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  // When we start a view transition, create a Deferred we can use for the\n  // eventual \"completed\" render\n  React.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  // Once the deferred is created, kick off startViewTransition() to update the\n  // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n  // happened)\n  React.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition = router.window.document.startViewTransition(async () => {\n        optInStartTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition.finished.finally(() => {\n        setRenderDfd(undefined);\n        setTransition(undefined);\n        setPendingState(undefined);\n        setVtContext({\n          isTransitioning: false\n        });\n      });\n      setTransition(transition);\n    }\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\n  // When the new location finally renders and is committed to the DOM, this\n  // effect will run to resolve the transition\n  React.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  // If we get interrupted with a new navigation during a transition, we skip\n  // the active transition, let it cleanup, then kick it off again here\n  React.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(undefined);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  React.useEffect(() => {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : void 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  let navigator = React.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(FetchersContext.Provider, {\n    value: fetcherData.current\n  }, /*#__PURE__*/React.createElement(ViewTransitionContext.Provider, {\n    value: vtContext\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/React.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state: state\n  }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n  let {\n    routes,\n    future,\n    state\n  } = _ref3;\n  return UNSAFE_useRoutesImpl(routes, undefined, state, future);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nfunction BrowserRouter(_ref4) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref4;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nfunction HashRouter(_ref5) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref5;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter(_ref6) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref6;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\nif (process.env.NODE_ENV !== \"production\") {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */\nconst Link = /*#__PURE__*/React.forwardRef(function LinkWithRef(_ref7, ref) {\n  let {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      unstable_viewTransition\n    } = _ref7,\n    rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  // Rendered into <a href> for absolute URLs\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n    // Render the absolute href server- and client-side\n    absoluteHref = to;\n    // Only check for external origins client-side\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = stripBasename(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          // Strip the protocol/origin/basename for same-origin absolute URLs\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        // We can't do external URL detection without a valid URL\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") : void 0;\n      }\n    }\n  }\n  // Rendered into <a href> for relative URLs\n  let href = useHref(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  });\n  function handleClick(event) {\n    if (onClick) onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return (\n    /*#__PURE__*/\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React.createElement(\"a\", _extends({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */\nconst NavLink = /*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref8, ref) {\n  let {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      unstable_viewTransition,\n      children\n    } = _ref8,\n    rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React.useContext(UNSAFE_DataRouterStateContext);\n  let {\n    navigator,\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let isTransitioning = routerState != null &&\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useViewTransitionState(path) && unstable_viewTransition === true;\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  if (nextLocationPathname && basename) {\n    nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;\n  }\n  // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n  // we're looking for a slash _after_ what's in `to`.  For example:\n  //\n  // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n  // both want to look for a / at index 6 to match URL `/users/matt`\n  const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let renderProps = {\n    isActive,\n    isPending,\n    isTransitioning\n  };\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  let className;\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp(renderProps);\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n  }\n  let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n  return /*#__PURE__*/React.createElement(Link, _extends({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to,\n    unstable_viewTransition: unstable_viewTransition\n  }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (process.env.NODE_ENV !== \"production\") {\n  NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nconst Form = /*#__PURE__*/React.forwardRef((_ref9, forwardedRef) => {\n  let {\n      fetcherKey,\n      navigate,\n      reloadDocument,\n      replace,\n      state,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    } = _ref9,\n    props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n  let submit = useSubmit();\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let submitHandler = event => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n    submit(submitter || event.currentTarget, {\n      fetcherKey,\n      method: submitMethod,\n      navigate,\n      replace,\n      state,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    });\n  };\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nfunction ScrollRestoration(_ref10) {\n  let {\n    getKey,\n    storageKey\n  } = _ref10;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (process.env.NODE_ENV !== \"production\") {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function (DataRouterHook) {\n  DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n  DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n  DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(UNSAFE_DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(UNSAFE_DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, {\n    relative\n  });\n  return React.useCallback(event => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      // If the URL hasn't changed, a regular <a> will do a replace instead of\n      // a push, so do the same here unless the replace prop is explicitly set\n      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nfunction useSearchParams(defaultInit) {\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : void 0;\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React.useRef(false);\n  let location = useLocation();\n  let searchParams = React.useMemo(() =>\n  // Only merge in the defaults if we haven't yet called setSearchParams.\n  // Once we call that we want those to take precedence, otherwise you can't\n  // remove a param with setSearchParams({}) if it has an initial value\n  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n  }\n}\nlet fetcherId = 0;\nlet getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmit);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let currentRouteId = UNSAFE_useRouteId();\n  return React.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    if (options.navigate === false) {\n      let key = options.fetcherKey || getUniqueFetcherId();\n      router.fetch(key, currentRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        unstable_flushSync: options.unstable_flushSync\n      });\n    } else {\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        unstable_flushSync: options.unstable_flushSync,\n        unstable_viewTransition: options.unstable_viewTransition\n      });\n    }\n  }, [router, basename, currentRouteId]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let routeContext = React.useContext(UNSAFE_RouteContext);\n  !routeContext ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFormAction must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = _extends({}, useResolvedPath(action ? action : \".\", {\n    relative\n  }));\n  // If no action was specified, browsers will persist current search params\n  // when determining the path, so match that behavior\n  // https://github.com/remix-run/remix/issues/927\n  let location = useLocation();\n  if (action == null) {\n    // Safe to write to this directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    path.search = location.search;\n    // When grabbing search params from the URL, remove any included ?index param\n    // since it might not apply to our contextual route.  We add it back based\n    // on match.route.index below\n    let params = new URLSearchParams(path.search);\n    if (params.has(\"index\") && params.get(\"index\") === \"\") {\n      params.delete(\"index\");\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nfunction useFetcher(_temp3) {\n  var _route$matches;\n  let {\n    key\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\n  let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n  let fetcherData = React.useContext(FetchersContext);\n  let route = React.useContext(UNSAFE_RouteContext);\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !fetcherData ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher must be used inside a FetchersContext\") : UNSAFE_invariant(false) : void 0;\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : UNSAFE_invariant(false) : void 0;\n  // Fetcher key handling\n  // OK to call conditionally to feature detect `useId`\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let defaultKey = useIdImpl ? useIdImpl() : \"\";\n  let [fetcherKey, setFetcherKey] = React.useState(key || defaultKey);\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  } else if (!fetcherKey) {\n    // We will only fall through here when `useId` is not available\n    setFetcherKey(getUniqueFetcherId());\n  }\n  // Registration/cleanup\n  React.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => {\n      // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n      // will not delete immediately but instead queue up a delete after the\n      // fetcher returns to an `idle` state\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  // Fetcher additions\n  let load = React.useCallback((href, opts) => {\n    !routeId ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"No routeId available for fetcher.load()\") : UNSAFE_invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href, opts);\n  }, [fetcherKey, routeId, router]);\n  let submitImpl = useSubmit();\n  let submit = React.useCallback((target, opts) => {\n    submitImpl(target, _extends({}, opts, {\n      navigate: false,\n      fetcherKey\n    }));\n  }, [fetcherKey, submitImpl]);\n  let FetcherForm = React.useMemo(() => {\n    let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {\n      return /*#__PURE__*/React.createElement(Form, _extends({}, props, {\n        navigate: false,\n        fetcherKey: fetcherKey,\n        ref: ref\n      }));\n    });\n    if (process.env.NODE_ENV !== \"production\") {\n      FetcherForm.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm;\n  }, [fetcherKey]);\n  // Exposed FetcherWithComponents\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = React.useMemo(() => _extends({\n    Form: FetcherForm,\n    submit,\n    load\n  }, fetcher, {\n    data\n  }), [FetcherForm, submit, load, fetcher, data]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nfunction useFetchers() {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return Array.from(state.fetchers.entries()).map(_ref11 => {\n    let [key, fetcher] = _ref11;\n    return _extends({}, fetcher, {\n      key\n    });\n  });\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration(_temp4) {\n  let {\n    getKey,\n    storageKey\n  } = _temp4 === void 0 ? {} : _temp4;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  // Trigger manual scroll restoration while we're active\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  // Save positions on pagehide\n  usePageHide(React.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    try {\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    } catch (error) {\n      process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : void 0;\n    }\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  // Read in any saved scroll locations\n  if (typeof document !== \"undefined\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches) => getKey( // Strip the basename to match useLocation()\n      _extends({}, location, {\n        pathname: stripBasename(location.pathname, basename) || location.pathname\n      }), matches) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      // Explicit false means don't do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      // try to scroll to the hash\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      // Don't reset if this navigation opted out\n      if (preventScrollReset === true) {\n        return;\n      }\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt(_ref12) {\n  let {\n    when,\n    message\n  } = _ref12;\n  let blocker = useBlocker(when);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        // This timeout is needed to avoid a weird \"race\" on POP navigations\n        // between the `window.history` revert navigation and the result of\n        // `window.confirm`\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */\nfunction useViewTransitionState(to, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let vtContext = React.useContext(ViewTransitionContext);\n  !(vtContext != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : UNSAFE_invariant(false) : void 0;\n  let {\n    basename\n  } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n  let path = useResolvedPath(to, {\n    relative: opts.relative\n  });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  // Transition is active if we're going to or coming from the indicated\n  // destination.  This ensures that other PUSH navigations that reverse\n  // an indicated transition apply.  I.e., on the list view you have:\n  //\n  //   <NavLink to=\"/details/1\" unstable_viewTransition>\n  //\n  // If you click the breadcrumb back to the list view:\n  //\n  //   <NavLink to=\"/list\" unstable_viewTransition>\n  //\n  // We should apply the transition because it's indicated as active going\n  // from /list -> /details/1 and therefore should be active on the reverse\n  // (even though this isn't strictly a POP reverse)\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n//#endregion\n\nexport { BrowserRouter, Form, HashRouter, Link, NavLink, RouterProvider, ScrollRestoration, FetchersContext as UNSAFE_FetchersContext, ViewTransitionContext as UNSAFE_ViewTransitionContext, useScrollRestoration as UNSAFE_useScrollRestoration, createBrowserRouter, createHashRouter, createSearchParams, HistoryRouter as unstable_HistoryRouter, usePrompt as unstable_usePrompt, useViewTransitionState as unstable_useViewTransitionState, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLinkClickHandler, useSearchParams, useSubmit };\n//# sourceMappingURL=index.js.map\n","// src/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred = class {\n  promise;\n  resolve;\n  reject;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n};\nfunction createLineSplittingTransform() {\n  const decoder = new TextDecoder();\n  let leftover = \"\";\n  return new TransformStream({\n    transform(chunk, controller) {\n      const str = decoder.decode(chunk, { stream: true });\n      const parts = (leftover + str).split(\"\\n\");\n      leftover = parts.pop() || \"\";\n      for (const part of parts) {\n        controller.enqueue(part);\n      }\n    },\n    flush(controller) {\n      if (leftover) {\n        controller.enqueue(leftover);\n      }\n    }\n  });\n}\n\n// src/flatten.ts\nfunction flatten(input) {\n  const { indices } = this;\n  const existing = indices.get(input);\n  if (existing)\n    return [existing];\n  if (input === void 0)\n    return UNDEFINED;\n  if (input === null)\n    return NULL;\n  if (Number.isNaN(input))\n    return NAN;\n  if (input === Number.POSITIVE_INFINITY)\n    return POSITIVE_INFINITY;\n  if (input === Number.NEGATIVE_INFINITY)\n    return NEGATIVE_INFINITY;\n  if (input === 0 && 1 / input < 0)\n    return NEGATIVE_ZERO;\n  const index = this.index++;\n  indices.set(input, index);\n  stringify.call(this, input, index);\n  return index;\n}\nfunction stringify(input, index) {\n  const { deferred, plugins } = this;\n  const str = this.stringified;\n  const partsForObj = (obj) => Object.keys(obj).map((k) => `\"${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n  switch (typeof input) {\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n      str[index] = JSON.stringify(input);\n      break;\n    case \"bigint\":\n      str[index] = `[\"${TYPE_BIGINT}\",\"${input}\"]`;\n      break;\n    case \"symbol\": {\n      const keyFor = Symbol.keyFor(input);\n      if (!keyFor)\n        throw new Error(\n          \"Cannot encode symbol unless created with Symbol.for()\"\n        );\n      str[index] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n      break;\n    }\n    case \"object\": {\n      if (!input) {\n        str[index] = `${NULL}`;\n        break;\n      }\n      const isArray = Array.isArray(input);\n      let pluginHandled = false;\n      if (!isArray && plugins) {\n        for (const plugin of plugins) {\n          const pluginResult = plugin(input);\n          if (Array.isArray(pluginResult)) {\n            pluginHandled = true;\n            const [pluginIdentifier, ...rest] = pluginResult;\n            str[index] = `[${JSON.stringify(pluginIdentifier)}`;\n            if (rest.length > 0) {\n              str[index] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n            }\n            str[index] += \"]\";\n            break;\n          }\n        }\n      }\n      if (!pluginHandled) {\n        let result = isArray ? \"[\" : \"{\";\n        if (isArray) {\n          for (let i = 0; i < input.length; i++)\n            result += (i ? \",\" : \"\") + (i in input ? flatten.call(this, input[i]) : HOLE);\n          str[index] = `${result}]`;\n        } else if (input instanceof Date) {\n          str[index] = `[\"${TYPE_DATE}\",${input.getTime()}]`;\n        } else if (input instanceof URL) {\n          str[index] = `[\"${TYPE_URL}\",${JSON.stringify(input.href)}]`;\n        } else if (input instanceof RegExp) {\n          str[index] = `[\"${TYPE_REGEXP}\",${JSON.stringify(\n            input.source\n          )},${JSON.stringify(input.flags)}]`;\n        } else if (input instanceof Set) {\n          if (input.size > 0) {\n            str[index] = `[\"${TYPE_SET}\",${[...input].map((val) => flatten.call(this, val)).join(\",\")}]`;\n          } else {\n            str[index] = `[\"${TYPE_SET}\"]`;\n          }\n        } else if (input instanceof Map) {\n          if (input.size > 0) {\n            str[index] = `[\"${TYPE_MAP}\",${[...input].flatMap(([k, v]) => [\n              flatten.call(this, k),\n              flatten.call(this, v)\n            ]).join(\",\")}]`;\n          } else {\n            str[index] = `[\"${TYPE_MAP}\"]`;\n          }\n        } else if (input instanceof Promise) {\n          str[index] = `[\"${TYPE_PROMISE}\",${index}]`;\n          deferred[index] = input;\n        } else if (input instanceof Error) {\n          str[index] = `[\"${TYPE_ERROR}\",${JSON.stringify(input.message)}`;\n          if (input.name !== \"Error\") {\n            str[index] += `,${JSON.stringify(input.name)}`;\n          }\n          str[index] += \"]\";\n        } else if (Object.getPrototypeOf(input) === null) {\n          str[index] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input)}}]`;\n        } else if (isPlainObject(input)) {\n          str[index] = `{${partsForObj(input)}}`;\n        } else {\n          throw new Error(\"Cannot encode object with prototype\");\n        }\n      }\n      break;\n    }\n    default: {\n      const isArray = Array.isArray(input);\n      let pluginHandled = false;\n      if (!isArray && plugins) {\n        for (const plugin of plugins) {\n          const pluginResult = plugin(input);\n          if (Array.isArray(pluginResult)) {\n            pluginHandled = true;\n            const [pluginIdentifier, ...rest] = pluginResult;\n            str[index] = `[${JSON.stringify(pluginIdentifier)}`;\n            if (rest.length > 0) {\n              str[index] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n            }\n            str[index] += \"]\";\n            break;\n          }\n        }\n      }\n      if (!pluginHandled) {\n        throw new Error(\"Cannot encode function or unexpected type\");\n      }\n    }\n  }\n}\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\0\");\nfunction isPlainObject(thing) {\n  const proto = Object.getPrototypeOf(thing);\n  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\0\") === objectProtoNames;\n}\n\n// src/unflatten.ts\nvar globalObj = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : void 0;\nfunction unflatten(parsed) {\n  const { hydrated, values } = this;\n  if (typeof parsed === \"number\")\n    return hydrate.call(this, parsed);\n  if (!Array.isArray(parsed) || !parsed.length)\n    throw new SyntaxError();\n  const startIndex = values.length;\n  values.push(...parsed);\n  hydrated.length = values.length;\n  return hydrate.call(this, startIndex);\n}\nfunction hydrate(index) {\n  const { hydrated, values, deferred, plugins } = this;\n  switch (index) {\n    case UNDEFINED:\n      return;\n    case NULL:\n      return null;\n    case NAN:\n      return NaN;\n    case POSITIVE_INFINITY:\n      return Infinity;\n    case NEGATIVE_INFINITY:\n      return -Infinity;\n    case NEGATIVE_ZERO:\n      return -0;\n  }\n  if (hydrated[index])\n    return hydrated[index];\n  const value = values[index];\n  if (!value || typeof value !== \"object\")\n    return hydrated[index] = value;\n  if (Array.isArray(value)) {\n    if (typeof value[0] === \"string\") {\n      const [type, b, c] = value;\n      switch (type) {\n        case TYPE_DATE:\n          return hydrated[index] = new Date(b);\n        case TYPE_URL:\n          return hydrated[index] = new URL(b);\n        case TYPE_BIGINT:\n          return hydrated[index] = BigInt(b);\n        case TYPE_REGEXP:\n          return hydrated[index] = new RegExp(b, c);\n        case TYPE_SYMBOL:\n          return hydrated[index] = Symbol.for(b);\n        case TYPE_SET:\n          const set = /* @__PURE__ */ new Set();\n          hydrated[index] = set;\n          for (let i = 1; i < value.length; i++)\n            set.add(hydrate.call(this, value[i]));\n          return set;\n        case TYPE_MAP:\n          const map = /* @__PURE__ */ new Map();\n          hydrated[index] = map;\n          for (let i = 1; i < value.length; i += 2) {\n            map.set(\n              hydrate.call(this, value[i]),\n              hydrate.call(this, value[i + 1])\n            );\n          }\n          return map;\n        case TYPE_NULL_OBJECT:\n          const obj = /* @__PURE__ */ Object.create(null);\n          hydrated[index] = obj;\n          for (const key in b)\n            obj[hydrate.call(this, Number(key))] = hydrate.call(this, b[key]);\n          return obj;\n        case TYPE_PROMISE:\n          if (hydrated[b]) {\n            return hydrated[index] = hydrated[b];\n          } else {\n            const d = new Deferred();\n            deferred[b] = d;\n            return hydrated[index] = d.promise;\n          }\n        case TYPE_ERROR:\n          const [, message, errorType] = value;\n          let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n          hydrated[index] = error;\n          return error;\n        case TYPE_PREVIOUS_RESOLVED:\n          return hydrate.call(this, b);\n        default:\n          if (Array.isArray(plugins)) {\n            const args = value.slice(1).map((i) => hydrate.call(this, i));\n            for (const plugin of plugins) {\n              const result = plugin(value[0], ...args);\n              if (result)\n                return hydrated[index] = result.value;\n            }\n          }\n          throw new SyntaxError();\n      }\n    } else {\n      const array = [];\n      hydrated[index] = array;\n      for (let i = 0; i < value.length; i++) {\n        const n = value[i];\n        if (n !== HOLE)\n          array[i] = hydrate.call(this, n);\n      }\n      return array;\n    }\n  } else {\n    const object = {};\n    hydrated[index] = object;\n    for (const key in value) {\n      object[hydrate.call(this, Number(key))] = hydrate.call(\n        this,\n        value[key]\n      );\n    }\n    return object;\n  }\n}\n\n// src/turbo-stream.ts\nasync function decode(readable, options) {\n  const { plugins } = options ?? {};\n  const done = new Deferred();\n  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n  const decoder = {\n    values: [],\n    hydrated: [],\n    deferred: {},\n    plugins\n  };\n  const decoded = await decodeInitial.call(decoder, reader);\n  let donePromise = done.promise;\n  if (decoded.done) {\n    done.resolve();\n  } else {\n    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {\n      for (const deferred of Object.values(decoder.deferred)) {\n        deferred.reject(reason);\n      }\n      done.reject(reason);\n    });\n  }\n  return {\n    done: donePromise.then(() => reader.closed),\n    value: decoded.value\n  };\n}\nasync function decodeInitial(reader) {\n  const read = await reader.read();\n  if (!read.value) {\n    throw new SyntaxError();\n  }\n  let line;\n  try {\n    line = JSON.parse(read.value);\n  } catch (reason) {\n    throw new SyntaxError();\n  }\n  return {\n    done: read.done,\n    value: unflatten.call(this, line)\n  };\n}\nasync function decodeDeferred(reader) {\n  let read = await reader.read();\n  while (!read.done) {\n    if (!read.value)\n      continue;\n    const line = read.value;\n    switch (line[0]) {\n      case TYPE_PROMISE: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.resolve(value);\n        break;\n      }\n      case TYPE_ERROR: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.reject(value);\n        break;\n      }\n      default:\n        throw new SyntaxError();\n    }\n    read = await reader.read();\n  }\n}\nfunction encode(input, options) {\n  const { plugins, signal } = options ?? {};\n  const encoder = {\n    deferred: {},\n    index: 0,\n    indices: /* @__PURE__ */ new Map(),\n    stringified: [],\n    plugins,\n    signal\n  };\n  const textEncoder = new TextEncoder();\n  let lastSentIndex = 0;\n  const readable = new ReadableStream({\n    async start(controller) {\n      const id = flatten.call(encoder, input);\n      if (Array.isArray(id)) {\n        throw new Error(\"This should never happen\");\n      }\n      if (id < 0) {\n        controller.enqueue(textEncoder.encode(`${id}\n`));\n      } else {\n        controller.enqueue(\n          textEncoder.encode(`[${encoder.stringified.join(\",\")}]\n`)\n        );\n        lastSentIndex = encoder.stringified.length - 1;\n      }\n      const seenPromises = /* @__PURE__ */ new WeakSet();\n      while (Object.keys(encoder.deferred).length > 0) {\n        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {\n          if (seenPromises.has(deferred))\n            continue;\n          seenPromises.add(\n            encoder.deferred[Number(deferredId)] = raceSignal(\n              deferred,\n              encoder.signal\n            ).then(\n              (resolved) => {\n                const id2 = flatten.call(encoder, resolved);\n                if (Array.isArray(id2)) {\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                    )\n                  );\n                } else if (id2 < 0) {\n                  controller.enqueue(\n                    textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}\n`)\n                  );\n                } else {\n                  const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_PROMISE}${deferredId}:[${values}]\n`\n                    )\n                  );\n                  lastSentIndex = encoder.stringified.length - 1;\n                }\n              },\n              (reason) => {\n                if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n                  reason = new Error(\"An unknown error occurred\");\n                }\n                const id2 = flatten.call(encoder, reason);\n                if (Array.isArray(id2)) {\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                    )\n                  );\n                } else if (id2 < 0) {\n                  controller.enqueue(\n                    textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}\n`)\n                  );\n                } else {\n                  const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                  controller.enqueue(\n                    textEncoder.encode(\n                      `${TYPE_ERROR}${deferredId}:[${values}]\n`\n                    )\n                  );\n                  lastSentIndex = encoder.stringified.length - 1;\n                }\n              }\n            ).finally(() => {\n              delete encoder.deferred[Number(deferredId)];\n            })\n          );\n        }\n        await Promise.race(Object.values(encoder.deferred));\n      }\n      await Promise.all(Object.values(encoder.deferred));\n      controller.close();\n    }\n  });\n  return readable;\n}\nfunction raceSignal(promise, signal) {\n  if (!signal)\n    return promise;\n  if (signal.aborted)\n    return Promise.reject(signal.reason || new Error(\"Signal was aborted.\"));\n  const abort = new Promise((resolve, reject) => {\n    signal.addEventListener(\"abort\", (event) => {\n      reject(signal.reason || new Error(\"Signal was aborted.\"));\n    });\n    promise.then(resolve).catch(reject);\n  });\n  abort.catch(() => {\n  });\n  return Promise.race([abort, promise]);\n}\nexport {\n  decode,\n  encode\n};\n","/**\n * @remix-run/server-runtime v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { UNSAFE_ErrorResponseImpl, isRouteErrorResponse } from '@remix-run/router';\nimport { encode } from 'turbo-stream';\nimport { sanitizeError, sanitizeErrors } from './errors.js';\nimport { ServerMode } from './mode.js';\nimport { isResponse, isDeferredData, isRedirectStatusCode } from './responses.js';\n\nconst SingleFetchRedirectSymbol = Symbol(\"SingleFetchRedirect\");\nconst ResponseStubActionSymbol = Symbol(\"ResponseStubAction\");\nfunction getSingleFetchDataStrategy(responseStubs, {\n  isActionDataRequest,\n  loadRouteIds\n} = {}) {\n  return async ({\n    request,\n    matches\n  }) => {\n    // Don't call loaders on action data requests\n    if (isActionDataRequest && request.method === \"GET\") {\n      return await Promise.all(matches.map(m => m.resolve(async () => ({\n        type: \"data\",\n        result: null\n      }))));\n    }\n    let results = await Promise.all(matches.map(async match => {\n      let responseStub;\n      if (request.method !== \"GET\") {\n        responseStub = responseStubs[ResponseStubActionSymbol];\n      } else {\n        responseStub = responseStubs[match.route.id];\n      }\n      let result = await match.resolve(async handler => {\n        // Cast `ResponseStubImpl -> ResponseStub` to hide the symbol in userland\n        let ctx = {\n          response: responseStub\n        };\n        // Only run opt-in loaders when fine-grained revalidation is enabled\n        let data = loadRouteIds && !loadRouteIds.includes(match.route.id) ? null : await handler(ctx);\n        return {\n          type: \"data\",\n          result: data\n        };\n      });\n\n      // Transfer raw Response status/headers to responseStubs\n      if (isResponse(result.result)) {\n        proxyResponseToResponseStub(result.result.status, result.result.headers, responseStub);\n      } else if (isDeferredData(result.result) && result.result.init) {\n        proxyResponseToResponseStub(result.result.init.status, new Headers(result.result.init.headers), responseStub);\n      }\n      return result;\n    }));\n    return results;\n  };\n}\nfunction getSingleFetchResourceRouteDataStrategy({\n  responseStubs\n}) {\n  return async ({\n    matches\n  }) => {\n    let results = await Promise.all(matches.map(async match => {\n      let responseStub = match.shouldLoad ? responseStubs[match.route.id] : null;\n      let result = await match.resolve(async handler => {\n        // Cast `ResponseStubImpl -> ResponseStub` to hide the symbol in userland\n        let ctx = {\n          response: responseStub\n        };\n        let data = await handler(ctx);\n        return {\n          type: \"data\",\n          result: data\n        };\n      });\n      return result;\n    }));\n    return results;\n  };\n}\nasync function singleFetchAction(serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      method: request.method,\n      body: request.body,\n      headers: request.headers,\n      signal: request.signal,\n      ...(request.body ? {\n        duplex: \"half\"\n      } : undefined)\n    });\n    let responseStubs = getResponseStubs();\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      unstable_dataStrategy: getSingleFetchDataStrategy(responseStubs, {\n        isActionDataRequest: true\n      })\n    });\n\n    // Unlike `handleDataRequest`, when singleFetch is enabled, query does\n    // let non-Response return values through\n    if (isResponse(result)) {\n      return {\n        result: getSingleFetchRedirect(result.status, result.headers),\n        headers: result.headers,\n        status: 200\n      };\n    }\n    let context = result;\n    let singleFetchResult;\n    let {\n      statusCode,\n      headers\n    } = mergeResponseStubs(context, responseStubs, {\n      isActionDataRequest: true\n    });\n    if (isRedirectStatusCode(statusCode) && headers.has(\"Location\")) {\n      return {\n        result: getSingleFetchRedirect(statusCode, headers),\n        headers,\n        status: 200 // Don't want the `fetch` call to follow the redirect\n      };\n    }\n\n    // Sanitize errors outside of development environments\n    if (context.errors) {\n      Object.values(context.errors).forEach(err => {\n        // @ts-expect-error This is \"private\" from users but intended for internal use\n        if ((!isRouteErrorResponse(err) || err.error) && !isResponseStub(err)) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    if (context.errors) {\n      let error = Object.values(context.errors)[0];\n      singleFetchResult = {\n        error: isResponseStub(error) ? null : error\n      };\n    } else {\n      singleFetchResult = {\n        data: Object.values(context.actionData || {})[0]\n      };\n    }\n    return {\n      result: singleFetchResult,\n      headers,\n      status: statusCode\n    };\n  } catch (error) {\n    handleError(error);\n    // These should only be internal remix errors, no need to deal with responseStubs\n    return {\n      result: {\n        error\n      },\n      headers: new Headers(),\n      status: 500\n    };\n  }\n}\nasync function singleFetchLoaders(serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    var _URL$searchParams$get;\n    let handlerRequest = new Request(handlerUrl, {\n      headers: request.headers,\n      signal: request.signal\n    });\n    let loadRouteIds = ((_URL$searchParams$get = new URL(request.url).searchParams.get(\"_routes\")) === null || _URL$searchParams$get === void 0 ? void 0 : _URL$searchParams$get.split(\",\")) || undefined;\n    let responseStubs = getResponseStubs();\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      unstable_dataStrategy: getSingleFetchDataStrategy(responseStubs, {\n        loadRouteIds\n      })\n    });\n    if (isResponse(result)) {\n      return {\n        result: {\n          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(result.status, result.headers)\n        },\n        headers: result.headers,\n        status: 200 // Don't want the `fetch` call to follow the redirect\n      };\n    }\n    let context = result;\n    let {\n      statusCode,\n      headers\n    } = mergeResponseStubs(context, responseStubs);\n    if (isRedirectStatusCode(statusCode) && headers.has(\"Location\")) {\n      return {\n        result: {\n          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(statusCode, headers)\n        },\n        headers,\n        status: 200 // Don't want the `fetch` call to follow the redirect\n      };\n    }\n\n    // Sanitize errors outside of development environments\n    if (context.errors) {\n      Object.values(context.errors).forEach(err => {\n        // @ts-expect-error This is \"private\" from users but intended for internal use\n        if ((!isRouteErrorResponse(err) || err.error) && !isResponseStub(err)) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n\n    // Aggregate results based on the matches we intended to load since we get\n    // `null` values back in `context.loaderData` for routes we didn't load\n    let results = {};\n    let loadedMatches = loadRouteIds ? context.matches.filter(m => m.route.loader && loadRouteIds.includes(m.route.id)) : context.matches;\n    loadedMatches.forEach(m => {\n      var _context$loaderData, _context$errors;\n      let data = (_context$loaderData = context.loaderData) === null || _context$loaderData === void 0 ? void 0 : _context$loaderData[m.route.id];\n      let error = (_context$errors = context.errors) === null || _context$errors === void 0 ? void 0 : _context$errors[m.route.id];\n      if (error !== undefined) {\n        if (isResponseStub(error)) {\n          results[m.route.id] = {\n            error: null\n          };\n        } else {\n          results[m.route.id] = {\n            error\n          };\n        }\n      } else if (data !== undefined) {\n        results[m.route.id] = {\n          data\n        };\n      }\n    });\n    return {\n      result: results,\n      headers,\n      status: statusCode\n    };\n  } catch (error) {\n    handleError(error);\n    // These should only be internal remix errors, no need to deal with responseStubs\n    return {\n      result: {\n        root: {\n          error\n        }\n      },\n      headers: new Headers(),\n      status: 500\n    };\n  }\n}\nfunction isResponseStub(value) {\n  return value && typeof value === \"object\" && ResponseStubOperationsSymbol in value;\n}\nfunction getResponseStub(status) {\n  let headers = new Headers();\n  let operations = [];\n  let headersProxy = new Proxy(headers, {\n    get(target, prop, receiver) {\n      if (prop === \"set\" || prop === \"append\" || prop === \"delete\") {\n        return (name, value) => {\n          operations.push([prop, name, value]);\n          Reflect.apply(target[prop], target, [name, value]);\n        };\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n  return {\n    status,\n    headers: headersProxy,\n    [ResponseStubOperationsSymbol]: operations\n  };\n}\nfunction getResponseStubs() {\n  return new Proxy({}, {\n    get(responseStubCache, prop) {\n      let cached = responseStubCache[prop];\n      if (!cached) {\n        responseStubCache[prop] = cached = getResponseStub();\n      }\n      return cached;\n    }\n  });\n}\nfunction proxyResponseToResponseStub(status, headers, responseStub) {\n  if (status != null && responseStub.status == null) {\n    responseStub.status = status;\n  }\n  for (let [k, v] of headers) {\n    if (k.toLowerCase() !== \"set-cookie\") {\n      responseStub.headers.set(k, v);\n    }\n  }\n\n  // Unsure why this is complaining?  It's fine in VSCode but fails with tsc...\n  // @ts-ignore - ignoring instead of expecting because otherwise build fails locally\n  for (let v of headers.getSetCookie()) {\n    responseStub.headers.append(\"Set-Cookie\", v);\n  }\n}\nfunction mergeResponseStubs(context, responseStubs, {\n  isActionDataRequest\n} = {}) {\n  let statusCode = undefined;\n  let headers = new Headers();\n\n  // Action followed by top-down loaders\n  let actionStub = responseStubs[ResponseStubActionSymbol];\n  let stubs = [actionStub];\n\n  // Nothing to merge at the route level on action data requests\n  if (!isActionDataRequest) {\n    stubs.push(...context.matches.map(m => responseStubs[m.route.id]));\n  }\n  for (let stub of stubs) {\n    // Take the highest error/redirect, or the lowest success value - preferring\n    // action 200's over loader 200s\n    if (\n    // first status found on the way down\n    statusCode === undefined && stub.status ||\n    // deeper 2xx status found while not overriding the action status\n    statusCode !== undefined && statusCode < 300 && stub.status && statusCode !== (actionStub === null || actionStub === void 0 ? void 0 : actionStub.status)) {\n      statusCode = stub.status;\n    }\n\n    // Replay headers operations in order\n    let ops = stub[ResponseStubOperationsSymbol];\n    for (let [op, ...args] of ops) {\n      // @ts-expect-error\n      headers[op](...args);\n    }\n  }\n\n  // If no response stubs set it, use whatever we got back from the router\n  // context which handles internal ErrorResponse cases like 404/405's where\n  // we may never run a loader/action\n  if (statusCode === undefined) {\n    statusCode = context.statusCode;\n  }\n  if (statusCode === undefined) {\n    statusCode = 200;\n  }\n  return {\n    statusCode,\n    headers\n  };\n}\nfunction getSingleFetchRedirect(status, headers) {\n  return {\n    redirect: headers.get(\"Location\"),\n    status,\n    revalidate:\n    // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n    // detail of ?_data requests as our way to tell the front end to revalidate when\n    // we didn't have a response body to include that information in.\n    // With single fetch, we tell the front end via this revalidate boolean field.\n    // However, we're respecting it for now because it may be something folks have\n    // used in their own responses\n    // TODO(v3): Consider removing or making this official public API\n    headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\"),\n    reload: headers.has(\"X-Remix-Reload-Document\")\n  };\n}\n\n// Note: If you change this function please change the corresponding\n// decodeViaTurboStream function in server-runtime\nfunction encodeViaTurboStream(data, requestSignal, streamTimeout, serverMode) {\n  let controller = new AbortController();\n  // How long are we willing to wait for all of the promises in `data` to resolve\n  // before timing out?  We default this to 50ms shorter than the default value for\n  // `ABORT_DELAY` in our built-in `entry.server.tsx` so that once we reject we\n  // have time to flush the rejections down through React's rendering stream before `\n  // we call abort() on that.  If the user provides their own it's up to them to\n  // decouple the aborting of the stream from the aborting of React's renderToPipeableStream\n  let timeoutId = setTimeout(() => controller.abort(new Error(\"Server Timeout\")), typeof streamTimeout === \"number\" ? streamTimeout : 4950);\n  requestSignal.addEventListener(\"abort\", () => clearTimeout(timeoutId));\n  return encode(data, {\n    signal: controller.signal,\n    plugins: [value => {\n      // Even though we sanitized errors on context.errors prior to responding,\n      // we still need to handle this for any deferred data that rejects with an\n      // Error - as those will not be sanitized yet\n      if (value instanceof Error) {\n        let {\n          name,\n          message,\n          stack\n        } = serverMode === ServerMode.Production ? sanitizeError(value, serverMode) : value;\n        return [\"SanitizedError\", name, message, stack];\n      }\n      if (value instanceof UNSAFE_ErrorResponseImpl) {\n        let {\n          data,\n          status,\n          statusText\n        } = value;\n        return [\"ErrorResponse\", data, status, statusText];\n      }\n      if (value && typeof value === \"object\" && SingleFetchRedirectSymbol in value) {\n        return [\"SingleFetchRedirect\", value[SingleFetchRedirectSymbol]];\n      }\n    }]\n  });\n}\n\n// Backwards-compatible type for Remix v2 where json/defer still use the old types,\n// and only non-json/defer returns use the new types.  This allows for incremental\n// migration of loaders to return naked objects.  In the next major version,\n// json/defer will be removed so everything will use the new simplified typings.\n// prettier-ignore\n\nconst ResponseStubOperationsSymbol = Symbol(\"ResponseStubOperations\");\n\n/**\n * A stubbed response to let you set the status/headers of your response from\n * loader/action functions\n */\n\n// loader\n\nlet defineLoader = loader => loader;\n\n// action\n\nlet defineAction = action => action;\n\nexport { ResponseStubOperationsSymbol, SingleFetchRedirectSymbol, defineAction, defineLoader, encodeViaTurboStream, getResponseStubs, getSingleFetchDataStrategy, getSingleFetchRedirect, getSingleFetchResourceRouteDataStrategy, isResponseStub, mergeResponseStubs, singleFetchAction, singleFetchLoaders };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nexport { _extends as extends };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nexport { invariant as default };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n/**\n * A function that handles data mutations for a route on the client\n */\n\n/**\n * Arguments passed to a route `clientAction` function\n */\n\n/**\n * A function that loads data for a route on the client\n */\n\n/**\n * Arguments passed to a route `clientLoader` function\n */\n\n/**\n * ErrorBoundary to display for this route\n */\n\n/**\n * `<Route HydrateFallback>` component to render on initial loads\n * when client loaders are present\n */\n\n/**\n * Optional, root-only `<Route Layout>` component to wrap the root content in.\n * Useful for defining the <html>/<head>/<body> document shell shared by the\n * Component, HydrateFallback, and ErrorBoundary\n */\n\n/**\n * A function that defines `<link>` tags to be inserted into the `<head>` of\n * the document on route transitions.\n *\n * @see https://remix.run/route/meta\n */\n\n/**\n * A React component that is rendered for a route.\n */\n\n/**\n * An arbitrary object that is associated with a route.\n *\n * @see https://remix.run/route/handle\n */\n\nasync function loadRouteModule(route, routeModulesCache) {\n  if (route.id in routeModulesCache) {\n    return routeModulesCache[route.id];\n  }\n  try {\n    let routeModule = await import( /* webpackIgnore: true */route.module);\n    routeModulesCache[route.id] = routeModule;\n    return routeModule;\n  } catch (error) {\n    // User got caught in the middle of a deploy and the CDN no longer has the\n    // asset we're trying to import! Reload from the server and the user\n    // (should) get the new manifest--unless the developer purged the static\n    // assets, the manifest path, but not the documents \n    if (window.__remixContext.isSpaMode &&\n    // @ts-expect-error\n    typeof import.meta.hot !== \"undefined\") {\n      // In SPA Mode (which implies vite) we don't want to perform a hard reload\n      // on dev-time errors since it's a vite compilation error and a reload is\n      // just going to fail with the same issue.  Let the UI bubble to the error\n      // boundary and let them see the error in the overlay or the dev server log\n      console.error(`Error loading route module \\`${route.module}\\`:`, error);\n      throw error;\n    }\n    window.location.reload();\n    return new Promise(() => {\n      // check out of this hook cause the DJs never gonna re[s]olve this\n    });\n  }\n}\n\nexport { loadRouteModule };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { parsePath } from 'react-router-dom';\nimport { loadRouteModule } from './routeModules.js';\n\n/**\n * Represents a `<link>` element.\n *\n * WHATWG Specification: https://html.spec.whatwg.org/multipage/semantics.html#the-link-element\n */\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Gets all the links for a set of matches. The modules are assumed to have been\n * loaded already.\n */\nfunction getKeyedLinksForMatches(matches, routeModules, manifest) {\n  let descriptors = matches.map(match => {\n    var _module$links;\n    let module = routeModules[match.route.id];\n    let route = manifest.routes[match.route.id];\n    return [route.css ? route.css.map(href => ({\n      rel: \"stylesheet\",\n      href\n    })) : [], (module === null || module === void 0 ? void 0 : (_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || []];\n  }).flat(2);\n  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);\n  return dedupeLinkDescriptors(descriptors, preloads);\n}\nasync function prefetchStyleLinks(route, routeModule) {\n  var _route$css, _routeModule$links;\n  if (!route.css && !routeModule.links || !isPreloadSupported()) return;\n  let descriptors = [((_route$css = route.css) === null || _route$css === void 0 ? void 0 : _route$css.map(href => ({\n    rel: \"stylesheet\",\n    href\n  }))) ?? [], ((_routeModule$links = routeModule.links) === null || _routeModule$links === void 0 ? void 0 : _routeModule$links.call(routeModule)) ?? []].flat(1);\n  if (descriptors.length === 0) return;\n  let styleLinks = [];\n  for (let descriptor of descriptors) {\n    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n      styleLinks.push({\n        ...descriptor,\n        rel: \"preload\",\n        as: \"style\"\n      });\n    }\n  }\n\n  // don't block for non-matching media queries, or for stylesheets that are\n  // already in the DOM (active route revalidations)\n  let matchingLinks = styleLinks.filter(link => (!link.media || window.matchMedia(link.media).matches) && !document.querySelector(`link[rel=\"stylesheet\"][href=\"${link.href}\"]`));\n  await Promise.all(matchingLinks.map(prefetchStyleLink));\n}\nasync function prefetchStyleLink(descriptor) {\n  return new Promise(resolve => {\n    let link = document.createElement(\"link\");\n    Object.assign(link, descriptor);\n    function removeLink() {\n      // if a navigation interrupts this prefetch React will update the <head>\n      // and remove the link we put in there manually, so we check if it's still\n      // there before trying to remove it\n      if (document.head.contains(link)) {\n        document.head.removeChild(link);\n      }\n    }\n    link.onload = () => {\n      removeLink();\n      resolve();\n    };\n    link.onerror = () => {\n      removeLink();\n      resolve();\n    };\n    document.head.appendChild(link);\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\nfunction isPageLinkDescriptor(object) {\n  return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n  if (object == null) {\n    return false;\n  }\n\n  // <link> may not have an href if <link rel=\"preload\"> is used with imageSrcSet + imageSizes\n  // https://github.com/remix-run/remix/issues/184\n  // https://html.spec.whatwg.org/commit-snapshots/cb4f5ff75de5f4cbd7013c4abad02f21c77d4d1c/#attr-link-imagesrcset\n  if (object.href == null) {\n    return object.rel === \"preload\" && typeof object.imageSrcSet === \"string\" && typeof object.imageSizes === \"string\";\n  }\n  return typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getKeyedPrefetchLinks(matches, manifest, routeModules) {\n  let links = await Promise.all(matches.map(async match => {\n    let mod = await loadRouteModule(manifest.routes[match.route.id], routeModules);\n    return mod.links ? mod.links() : [];\n  }));\n  return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter(link => link.rel === \"stylesheet\" || link.rel === \"preload\").map(link => link.rel === \"stylesheet\" ? {\n    ...link,\n    rel: \"prefetch\",\n    as: \"style\"\n  } : {\n    ...link,\n    rel: \"prefetch\"\n  }));\n}\n\n// This is ridiculously identical to transition.ts `filterMatchesToLoad`\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {\n  let path = parsePathPatch(page);\n  let isNew = (match, index) => {\n    if (!currentMatches[index]) return true;\n    return match.route.id !== currentMatches[index].route.id;\n  };\n  let matchPathChanged = (match, index) => {\n    var _currentMatches$index;\n    return (\n      // param change, /users/123 -> /users/456\n      currentMatches[index].pathname !== match.pathname ||\n      // splat param changed, which is not present in match.path\n      // e.g. /files/images/avatar.jpg -> files/finances.xls\n      ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith(\"*\")) && currentMatches[index].params[\"*\"] !== match.params[\"*\"]\n    );\n  };\n\n  // NOTE: keep this mostly up-to-date w/ the transition data diff, but this\n  // version doesn't care about submissions\n  let newMatches = mode === \"data\" && location.search !== path.search ?\n  // this is really similar to stuff in transition.ts, maybe somebody smarter\n  // than me (or in less of a hurry) can share some of it. You're the best.\n  nextMatches.filter((match, index) => {\n    let manifestRoute = manifest.routes[match.route.id];\n    if (!manifestRoute.hasLoader) {\n      return false;\n    }\n    if (isNew(match, index) || matchPathChanged(match, index)) {\n      return true;\n    }\n    if (match.route.shouldRevalidate) {\n      var _currentMatches$;\n      let routeChoice = match.route.shouldRevalidate({\n        currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),\n        currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},\n        nextUrl: new URL(page, window.origin),\n        nextParams: match.params,\n        defaultShouldRevalidate: true\n      });\n      if (typeof routeChoice === \"boolean\") {\n        return routeChoice;\n      }\n    }\n    return true;\n  }) : nextMatches.filter((match, index) => {\n    let manifestRoute = manifest.routes[match.route.id];\n    return (mode === \"assets\" || manifestRoute.hasLoader) && (isNew(match, index) || matchPathChanged(match, index));\n  });\n  return newMatches;\n}\nfunction getDataLinkHrefs(page, matches, manifest) {\n  let path = parsePathPatch(page);\n  return dedupeHrefs(matches.filter(match => manifest.routes[match.route.id].hasLoader).map(match => {\n    let {\n      pathname,\n      search\n    } = path;\n    let searchParams = new URLSearchParams(search);\n    searchParams.set(\"_data\", match.route.id);\n    return `${pathname}?${searchParams}`;\n  }));\n}\nfunction getModuleLinkHrefs(matches, manifestPatch) {\n  return dedupeHrefs(matches.map(match => {\n    let route = manifestPatch.routes[match.route.id];\n    let hrefs = [route.module];\n    if (route.imports) {\n      hrefs = hrefs.concat(route.imports);\n    }\n    return hrefs;\n  }).flat(1));\n}\n\n// The `<Script>` will render rel=modulepreload for the current page, we don't\n// need to include them in a page prefetch, this gives us the list to remove\n// while deduping.\nfunction getCurrentPageModulePreloadHrefs(matches, manifest) {\n  return dedupeHrefs(matches.map(match => {\n    let route = manifest.routes[match.route.id];\n    let hrefs = [route.module];\n    if (route.imports) {\n      hrefs = hrefs.concat(route.imports);\n    }\n    return hrefs;\n  }).flat(1));\n}\nfunction dedupeHrefs(hrefs) {\n  return [...new Set(hrefs)];\n}\nfunction sortKeys(obj) {\n  let sorted = {};\n  let keys = Object.keys(obj).sort();\n  for (let key of keys) {\n    sorted[key] = obj[key];\n  }\n  return sorted;\n}\nfunction dedupeLinkDescriptors(descriptors, preloads) {\n  let set = new Set();\n  let preloadsSet = new Set(preloads);\n  return descriptors.reduce((deduped, descriptor) => {\n    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n    if (alreadyModulePreload) {\n      return deduped;\n    }\n    let key = JSON.stringify(sortKeys(descriptor));\n    if (!set.has(key)) {\n      set.add(key);\n      deduped.push({\n        key,\n        link: descriptor\n      });\n    }\n    return deduped;\n  }, []);\n}\n\n// https://github.com/remix-run/history/issues/897\nfunction parsePathPatch(href) {\n  let path = parsePath(href);\n  if (path.search === undefined) path.search = \"\";\n  return path;\n}\n\n// Detect if this browser supports <link rel=\"preload\"> (or has it enabled).\n// Originally added to handle the firefox `network.preload` config:\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1847811\nlet _isPreloadSupported;\nfunction isPreloadSupported() {\n  if (_isPreloadSupported !== undefined) {\n    return _isPreloadSupported;\n  }\n  let el = document.createElement(\"link\");\n  _isPreloadSupported = el.relList.supports(\"preload\");\n  el = null;\n  return _isPreloadSupported;\n}\n\nexport { getDataLinkHrefs, getKeyedLinksForMatches, getKeyedPrefetchLinks, getModuleLinkHrefs, getNewMatchesForLinks, isPageLinkDescriptor, prefetchStyleLinks };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n// This escapeHtml utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\n\n// We've chosen to inline the utility here to reduce the number of npm dependencies we have,\n// slightly decrease the code size compared the original package and make it esm compatible.\n\nconst ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nconst ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n  return html.replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\nfunction createHtml(html) {\n  return {\n    __html: html\n  };\n}\n\nexport { createHtml, escapeHtml };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { AbortedDeferredError, UNSAFE_DeferredData } from '@remix-run/router';\n\n/**\n * Data for a route that was returned from a `loader()`.\n */\n\nfunction isCatchResponse(response) {\n  return response.headers.get(\"X-Remix-Catch\") != null;\n}\nfunction isErrorResponse(response) {\n  return response.headers.get(\"X-Remix-Error\") != null;\n}\nfunction isNetworkErrorResponse(response) {\n  // If we reach the Remix server, we can safely identify response types via the\n  // X-Remix-Error/X-Remix-Catch headers.  However, if we never reach the Remix\n  // server, and instead receive a 4xx/5xx from somewhere in between (like\n  // Cloudflare), then we get a false negative in the isErrorResponse check and\n  // we incorrectly assume that the user returns the 4xx/5xx response and\n  // consider it successful.  To alleviate this, we add X-Remix-Response to any\n  // non-Error/non-Catch responses coming back from the server.  If we don't\n  // see this, we can conclude that a 4xx/5xx response never actually reached\n  // the Remix server and we can bubble it up as an error.\n  return isResponse(response) && response.status >= 400 && response.headers.get(\"X-Remix-Error\") == null && response.headers.get(\"X-Remix-Catch\") == null && response.headers.get(\"X-Remix-Response\") == null;\n}\nfunction isRedirectResponse(response) {\n  return response.headers.get(\"X-Remix-Redirect\") != null;\n}\nfunction isDeferredResponse(response) {\n  var _response$headers$get;\n  return !!((_response$headers$get = response.headers.get(\"Content-Type\")) !== null && _response$headers$get !== void 0 && _response$headers$get.match(/text\\/remix-deferred/));\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nasync function fetchData(request, routeId, retry = 0) {\n  let url = new URL(request.url);\n  url.searchParams.set(\"_data\", routeId);\n  if (retry > 0) {\n    // Retry up to 3 times waiting 50, 250, 1250 ms\n    // between retries for a total of 1550 ms before giving up.\n    await new Promise(resolve => setTimeout(resolve, 5 ** retry * 10));\n  }\n  let init = await createRequestInit(request);\n  let revalidation = window.__remixRevalidation;\n  let response = await fetch(url.href, init).catch(error => {\n    if (typeof revalidation === \"number\" && revalidation === window.__remixRevalidation && (error === null || error === void 0 ? void 0 : error.name) === \"TypeError\" && retry < 3) {\n      return fetchData(request, routeId, retry + 1);\n    }\n    throw error;\n  });\n  if (isErrorResponse(response)) {\n    let data = await response.json();\n    let error = new Error(data.message);\n    error.stack = data.stack;\n    return error;\n  }\n  if (isNetworkErrorResponse(response)) {\n    let text = await response.text();\n    let error = new Error(text);\n    error.stack = undefined;\n    return error;\n  }\n  return response;\n}\nasync function createRequestInit(request) {\n  let init = {\n    signal: request.signal\n  };\n  if (request.method !== \"GET\") {\n    init.method = request.method;\n    let contentType = request.headers.get(\"Content-Type\");\n\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      init.headers = {\n        \"Content-Type\": contentType\n      };\n      init.body = JSON.stringify(await request.json());\n    } else if (contentType && /\\btext\\/plain\\b/.test(contentType)) {\n      init.headers = {\n        \"Content-Type\": contentType\n      };\n      init.body = await request.text();\n    } else if (contentType && /\\bapplication\\/x-www-form-urlencoded\\b/.test(contentType)) {\n      init.body = new URLSearchParams(await request.text());\n    } else {\n      init.body = await request.formData();\n    }\n  }\n  return init;\n}\nconst DEFERRED_VALUE_PLACEHOLDER_PREFIX = \"__deferred_promise:\";\nasync function parseDeferredReadableStream(stream) {\n  if (!stream) {\n    throw new Error(\"parseDeferredReadableStream requires stream argument\");\n  }\n  let deferredData;\n  let deferredResolvers = {};\n  try {\n    let sectionReader = readStreamSections(stream);\n\n    // Read the first section to get the critical data\n    let initialSectionResult = await sectionReader.next();\n    let initialSection = initialSectionResult.value;\n    if (!initialSection) throw new Error(\"no critical data\");\n    let criticalData = JSON.parse(initialSection);\n\n    // Setup deferred data and resolvers for later based on the critical data\n    if (typeof criticalData === \"object\" && criticalData !== null) {\n      for (let [eventKey, value] of Object.entries(criticalData)) {\n        if (typeof value !== \"string\" || !value.startsWith(DEFERRED_VALUE_PLACEHOLDER_PREFIX)) {\n          continue;\n        }\n        deferredData = deferredData || {};\n        deferredData[eventKey] = new Promise((resolve, reject) => {\n          deferredResolvers[eventKey] = {\n            resolve: value => {\n              resolve(value);\n              delete deferredResolvers[eventKey];\n            },\n            reject: error => {\n              reject(error);\n              delete deferredResolvers[eventKey];\n            }\n          };\n        });\n      }\n    }\n\n    // Read the rest of the stream and resolve deferred promises\n    void (async () => {\n      try {\n        for await (let section of sectionReader) {\n          // Determine event type and data\n          let [event, ...sectionDataStrings] = section.split(\":\");\n          let sectionDataString = sectionDataStrings.join(\":\");\n          let data = JSON.parse(sectionDataString);\n          if (event === \"data\") {\n            for (let [key, value] of Object.entries(data)) {\n              if (deferredResolvers[key]) {\n                deferredResolvers[key].resolve(value);\n              }\n            }\n          } else if (event === \"error\") {\n            for (let [key, value] of Object.entries(data)) {\n              let err = new Error(value.message);\n              err.stack = value.stack;\n              if (deferredResolvers[key]) {\n                deferredResolvers[key].reject(err);\n              }\n            }\n          }\n        }\n        for (let [key, resolver] of Object.entries(deferredResolvers)) {\n          resolver.reject(new AbortedDeferredError(`Deferred ${key} will never be resolved`));\n        }\n      } catch (error) {\n        // Reject any existing deferred promises if something blows up\n        for (let resolver of Object.values(deferredResolvers)) {\n          resolver.reject(error);\n        }\n      }\n    })();\n    return new UNSAFE_DeferredData({\n      ...criticalData,\n      ...deferredData\n    });\n  } catch (error) {\n    for (let resolver of Object.values(deferredResolvers)) {\n      resolver.reject(error);\n    }\n    throw error;\n  }\n}\nasync function* readStreamSections(stream) {\n  let reader = stream.getReader();\n  let buffer = [];\n  let sections = [];\n  let closed = false;\n  let encoder = new TextEncoder();\n  let decoder = new TextDecoder();\n  let readStreamSection = async () => {\n    if (sections.length > 0) return sections.shift();\n\n    // Read from the stream until we have at least one complete section to process\n    while (!closed && sections.length === 0) {\n      let chunk = await reader.read();\n      if (chunk.done) {\n        closed = true;\n        break;\n      }\n      // Buffer the raw chunks\n      buffer.push(chunk.value);\n      try {\n        // Attempt to split off a section from the buffer\n        let bufferedString = decoder.decode(mergeArrays(...buffer));\n        let splitSections = bufferedString.split(\"\\n\\n\");\n        if (splitSections.length >= 2) {\n          // We have a complete section, so add it to the sections array\n          sections.push(...splitSections.slice(0, -1));\n          // Remove the section from the buffer and store the rest for future processing\n          buffer = [encoder.encode(splitSections.slice(-1).join(\"\\n\\n\"))];\n        }\n\n        // If we successfully parsed at least one section, break out of reading the stream\n        // to allow upstream processing of the processable sections\n        if (sections.length > 0) {\n          break;\n        }\n      } catch {\n        // If we failed to parse the buffer it was because we failed to decode the stream\n        // because we are missing bytes that we haven't yet received, so continue reading\n        // from the stream until we have a complete section\n        continue;\n      }\n    }\n\n    // If we have a complete section, return it\n    if (sections.length > 0) {\n      return sections.shift();\n    }\n\n    // If we have no complete section, but we have no more chunks to process,\n    // split those sections and clear out the buffer as there is no more data\n    // to process. If this errors, let it bubble up as the stream ended\n    // without valid data\n    if (buffer.length > 0) {\n      let bufferedString = decoder.decode(mergeArrays(...buffer));\n      sections = bufferedString.split(\"\\n\\n\").filter(s => s);\n      buffer = [];\n    }\n\n    // Return any remaining sections that have been processed\n    return sections.shift();\n  };\n  let section = await readStreamSection();\n  while (section) {\n    yield section;\n    section = await readStreamSection();\n  }\n}\nfunction mergeArrays(...arrays) {\n  let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));\n  let offset = 0;\n  for (let arr of arrays) {\n    out.set(arr, offset);\n    offset += arr.length;\n  }\n  return out;\n}\n\nexport { createRequestInit, fetchData, isCatchResponse, isDeferredData, isDeferredResponse, isErrorResponse, isNetworkErrorResponse, isRedirectResponse, isResponse, parseDeferredReadableStream };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_ErrorResponseImpl, redirect } from '@remix-run/router';\nimport { UNSAFE_SingleFetchRedirectSymbol } from '@remix-run/server-runtime';\nimport { decode } from 'turbo-stream';\nimport { createRequestInit } from './data.js';\nimport { escapeHtml } from './markup.js';\nimport invariant from './invariant.js';\n\n// clientLoader\n\nlet defineClientLoader = clientLoader => clientLoader;\n\n// clientAction\n\nlet defineClientAction = clientAction => clientAction;\n// StreamTransfer recursively renders down chunks of the `serverHandoffStream`\n// into the client-side `streamController`\nfunction StreamTransfer({\n  context,\n  identifier,\n  reader,\n  textDecoder,\n  nonce\n}) {\n  // If the user didn't render the <Scripts> component then we don't have to\n  // bother streaming anything in\n  if (!context.renderMeta || !context.renderMeta.didRenderScripts) {\n    return null;\n  }\n  if (!context.renderMeta.streamCache) {\n    context.renderMeta.streamCache = {};\n  }\n  let {\n    streamCache\n  } = context.renderMeta;\n  let promise = streamCache[identifier];\n  if (!promise) {\n    promise = streamCache[identifier] = reader.read().then(result => {\n      streamCache[identifier].result = {\n        done: result.done,\n        value: textDecoder.decode(result.value, {\n          stream: true\n        })\n      };\n    }).catch(e => {\n      streamCache[identifier].error = e;\n    });\n  }\n  if (promise.error) {\n    throw promise.error;\n  }\n  if (promise.result === undefined) {\n    throw promise;\n  }\n  let {\n    done,\n    value\n  } = promise.result;\n  let scriptTag = value ? /*#__PURE__*/React.createElement(\"script\", {\n    nonce: nonce,\n    dangerouslySetInnerHTML: {\n      __html: `window.__remixContext.streamController.enqueue(${escapeHtml(JSON.stringify(value))});`\n    }\n  }) : null;\n  if (done) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, scriptTag, /*#__PURE__*/React.createElement(\"script\", {\n      nonce: nonce,\n      dangerouslySetInnerHTML: {\n        __html: `window.__remixContext.streamController.close();`\n      }\n    }));\n  } else {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, scriptTag, /*#__PURE__*/React.createElement(React.Suspense, null, /*#__PURE__*/React.createElement(StreamTransfer, {\n      context: context,\n      identifier: identifier + 1,\n      reader: reader,\n      textDecoder: textDecoder,\n      nonce: nonce\n    })));\n  }\n}\nfunction getSingleFetchDataStrategy(manifest, routeModules) {\n  return async ({\n    request,\n    matches\n  }) => request.method !== \"GET\" ? singleFetchActionStrategy(request, matches) : singleFetchLoaderStrategy(manifest, routeModules, request, matches);\n}\n\n// Actions are simple since they're singular calls to the server\nfunction singleFetchActionStrategy(request, matches) {\n  return Promise.all(matches.map(async m => {\n    let actionStatus;\n    let result = await m.resolve(async handler => {\n      let result = await handler(async () => {\n        let url = singleFetchUrl(request.url);\n        let init = await createRequestInit(request);\n        let {\n          data,\n          status\n        } = await fetchAndDecode(url, init);\n        actionStatus = status;\n        return unwrapSingleFetchResult(data, m.route.id);\n      });\n      return {\n        type: \"data\",\n        result,\n        status: actionStatus\n      };\n    });\n    return {\n      ...result,\n      // Proxy along the action HTTP response status for thrown errors\n      status: actionStatus\n    };\n  }));\n}\n\n// Loaders are trickier since we only want to hit the server once, so we\n// create a singular promise for all server-loader routes to latch onto.\nfunction singleFetchLoaderStrategy(manifest, routeModules, request, matches) {\n  let singleFetchPromise;\n  return Promise.all(matches.map(async m => m.resolve(async handler => {\n    let result;\n    let url = stripIndexParam(singleFetchUrl(request.url));\n\n    // When a route has a client loader, it calls it's singular server loader\n    if (manifest.routes[m.route.id].hasClientLoader) {\n      result = await handler(async () => {\n        url.searchParams.set(\"_routes\", m.route.id);\n        let {\n          data\n        } = await fetchAndDecode(url);\n        return unwrapSingleFetchResults(data, m.route.id);\n      });\n    } else {\n      result = await handler(async () => {\n        // Otherwise we let multiple routes hook onto the same promise\n        if (!singleFetchPromise) {\n          url = addRevalidationParam(manifest, routeModules, matches.map(m => m.route), matches.filter(m => m.shouldLoad).map(m => m.route), url);\n          singleFetchPromise = fetchAndDecode(url).then(({\n            data\n          }) => data);\n        }\n        let results = await singleFetchPromise;\n        return unwrapSingleFetchResults(results, m.route.id);\n      });\n    }\n    return {\n      type: \"data\",\n      result\n    };\n  })));\n}\nfunction stripIndexParam(url) {\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  return url;\n}\n\n// Determine which routes we want to load so we can add a `?_routes` search param\n// for fine-grained revalidation if necessary. There's some nuance to this decision:\n//\n//  - The presence of `shouldRevalidate` and `clientLoader` functions are the only\n//    way to trigger fine-grained single fetch loader calls.  without either of\n//    these on the route matches we just always ask for the full `.data` request.\n//  - If any routes have a `shouldRevalidate` or `clientLoader` then we do a\n//    comparison of the routes we matched and the routes we're aiming to load\n//  - If they don't match up, then we add the `_routes` param or fine-grained\n//    loading\n//  - This is used by the single fetch implementation above and by the\n//    `<PrefetchPageLinksImpl>` component so we can prefetch routes using the\n//    same logic\nfunction addRevalidationParam(manifest, routeModules, matchedRoutes, loadRoutes, url) {\n  let genRouteIds = arr => arr.filter(id => manifest.routes[id].hasLoader).join(\",\");\n\n  // Look at the `routeModules` for `shouldRevalidate` here instead of the manifest\n  // since HDR adds a wrapper for `shouldRevalidate` even if the route didn't have one\n  // initially.\n  // TODO: We probably can get rid of that wrapper once we're strictly on on\n  // single-fetch in v3 and just leverage a needsRevalidation data structure here\n  // to determine what to fetch\n  let needsParam = matchedRoutes.some(r => {\n    var _routeModules$r$id, _manifest$routes$r$id;\n    return ((_routeModules$r$id = routeModules[r.id]) === null || _routeModules$r$id === void 0 ? void 0 : _routeModules$r$id.shouldRevalidate) || ((_manifest$routes$r$id = manifest.routes[r.id]) === null || _manifest$routes$r$id === void 0 ? void 0 : _manifest$routes$r$id.hasClientLoader);\n  });\n  if (!needsParam) {\n    return url;\n  }\n  let matchedIds = genRouteIds(matchedRoutes.map(r => r.id));\n  let loadIds = genRouteIds(loadRoutes.filter(r => {\n    var _manifest$routes$r$id2;\n    return !((_manifest$routes$r$id2 = manifest.routes[r.id]) !== null && _manifest$routes$r$id2 !== void 0 && _manifest$routes$r$id2.hasClientLoader);\n  }).map(r => r.id));\n  if (matchedIds !== loadIds) {\n    url.searchParams.set(\"_routes\", loadIds);\n  }\n  return url;\n}\nfunction singleFetchUrl(reqUrl) {\n  let url = typeof reqUrl === \"string\" ? new URL(reqUrl, window.location.origin) : reqUrl;\n  url.pathname = `${url.pathname === \"/\" ? \"_root\" : url.pathname}.data`;\n  return url;\n}\nasync function fetchAndDecode(url, init) {\n  let res = await fetch(url, init);\n  // Don't do a hard check against the header here.  We'll get `text/x-turbo`\n  // when we have a running server, but if folks want to prerender `.data` files\n  // and serve them from a CDN we should let them come back with whatever\n  // Content-Type their CDN provides and not force them to make sure `.data`\n  // files are served as `text/x-turbo`.  We'll throw if we can't decode anyway.\n  invariant(res.body, \"No response body to decode\");\n  try {\n    let decoded = await decodeViaTurboStream(res.body, window);\n    return {\n      status: res.status,\n      data: decoded.value\n    };\n  } catch (e) {\n    console.error(e);\n    throw new Error(`Unable to decode turbo-stream response from URL: ${url.toString()}`);\n  }\n}\n\n// Note: If you change this function please change the corresponding\n// encodeViaTurboStream function in server-runtime\nfunction decodeViaTurboStream(body, global) {\n  return decode(body, {\n    plugins: [(type, ...rest) => {\n      // Decode Errors back into Error instances using the right type and with\n      // the right (potentially undefined) stacktrace\n      if (type === \"SanitizedError\") {\n        let [name, message, stack] = rest;\n        let Constructor = Error;\n        // @ts-expect-error\n        if (name && name in global && typeof global[name] === \"function\") {\n          // @ts-expect-error\n          Constructor = global[name];\n        }\n        let error = new Constructor(message);\n        error.stack = stack;\n        return {\n          value: error\n        };\n      }\n      if (type === \"ErrorResponse\") {\n        let [data, status, statusText] = rest;\n        return {\n          value: new UNSAFE_ErrorResponseImpl(status, statusText, data)\n        };\n      }\n      if (type === \"SingleFetchRedirect\") {\n        return {\n          value: {\n            [UNSAFE_SingleFetchRedirectSymbol]: rest[0]\n          }\n        };\n      }\n    }]\n  });\n}\nfunction unwrapSingleFetchResults(results, routeId) {\n  let redirect = results[UNSAFE_SingleFetchRedirectSymbol];\n  if (redirect) {\n    return unwrapSingleFetchResult(redirect, routeId);\n  }\n  return results[routeId] !== undefined ? unwrapSingleFetchResult(results[routeId], routeId) : null;\n}\nfunction unwrapSingleFetchResult(result, routeId) {\n  if (\"error\" in result) {\n    throw result.error;\n  } else if (\"redirect\" in result) {\n    let headers = {};\n    if (result.revalidate) {\n      headers[\"X-Remix-Revalidate\"] = \"yes\";\n    }\n    if (result.reload) {\n      headers[\"X-Remix-Reload-Document\"] = \"yes\";\n    }\n    return redirect(result.redirect, {\n      status: result.status,\n      headers\n    });\n  } else if (\"data\" in result) {\n    return result.data;\n  } else {\n    throw new Error(`No response found for routeId \"${routeId}\"`);\n  }\n}\n\nexport { StreamTransfer, addRevalidationParam, decodeViaTurboStream, defineClientAction, defineClientLoader, getSingleFetchDataStrategy, singleFetchUrl };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { extends as _extends } from './_virtual/_rollupPluginBabelHelpers.js';\nimport * as React from 'react';\nimport { useHref, NavLink as NavLink$1, Link as Link$1, matchRoutes, useLocation, Await as Await$1, useNavigation, useAsyncError, useMatches as useMatches$1, useLoaderData as useLoaderData$1, useRouteLoaderData as useRouteLoaderData$1, useActionData as useActionData$1, useFetcher as useFetcher$1, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext } from 'react-router-dom';\nimport invariant from './invariant.js';\nimport { getKeyedLinksForMatches, isPageLinkDescriptor, getNewMatchesForLinks, getDataLinkHrefs, getModuleLinkHrefs, getKeyedPrefetchLinks } from './links.js';\nimport { escapeHtml, createHtml } from './markup.js';\nimport { addRevalidationParam, singleFetchUrl } from './single-fetch.js';\n\nfunction useDataRouterContext() {\n  let context = React.useContext(UNSAFE_DataRouterContext);\n  invariant(context, \"You must render this element inside a <DataRouterContext.Provider> element\");\n  return context;\n}\nfunction useDataRouterStateContext() {\n  let context = React.useContext(UNSAFE_DataRouterStateContext);\n  invariant(context, \"You must render this element inside a <DataRouterStateContext.Provider> element\");\n  return context;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// RemixContext\n\nconst RemixContext = /*#__PURE__*/React.createContext(undefined);\nRemixContext.displayName = \"Remix\";\nfunction useRemixContext() {\n  let context = React.useContext(RemixContext);\n  invariant(context, \"You must render this element inside a <Remix> element\");\n  return context;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Public API\n\n/**\n * Defines the prefetching behavior of the link:\n *\n * - \"none\": Never fetched\n * - \"intent\": Fetched when the user focuses or hovers the link\n * - \"render\": Fetched when the link is rendered\n * - \"viewport\": Fetched when the link is in the viewport\n */\n\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n  let [maybePrefetch, setMaybePrefetch] = React.useState(false);\n  let [shouldPrefetch, setShouldPrefetch] = React.useState(false);\n  let {\n    onFocus,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart\n  } = theirElementProps;\n  let ref = React.useRef(null);\n  React.useEffect(() => {\n    if (prefetch === \"render\") {\n      setShouldPrefetch(true);\n    }\n    if (prefetch === \"viewport\") {\n      let callback = entries => {\n        entries.forEach(entry => {\n          setShouldPrefetch(entry.isIntersecting);\n        });\n      };\n      let observer = new IntersectionObserver(callback, {\n        threshold: 0.5\n      });\n      if (ref.current) observer.observe(ref.current);\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [prefetch]);\n  let setIntent = () => {\n    if (prefetch === \"intent\") {\n      setMaybePrefetch(true);\n    }\n  };\n  let cancelIntent = () => {\n    if (prefetch === \"intent\") {\n      setMaybePrefetch(false);\n      setShouldPrefetch(false);\n    }\n  };\n  React.useEffect(() => {\n    if (maybePrefetch) {\n      let id = setTimeout(() => {\n        setShouldPrefetch(true);\n      }, 100);\n      return () => {\n        clearTimeout(id);\n      };\n    }\n  }, [maybePrefetch]);\n  return [shouldPrefetch, ref, {\n    onFocus: composeEventHandlers(onFocus, setIntent),\n    onBlur: composeEventHandlers(onBlur, cancelIntent),\n    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n    onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n  }];\n}\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\n/**\n * A special kind of `<Link>` that knows whether it is \"active\".\n *\n * @see https://remix.run/components/nav-link\n */\nlet NavLink = /*#__PURE__*/React.forwardRef(({\n  to,\n  prefetch = \"none\",\n  ...props\n}, forwardedRef) => {\n  let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to);\n  let href = useHref(to);\n  let [shouldPrefetch, ref, prefetchHandlers] = usePrefetchBehavior(prefetch, props);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(NavLink$1, _extends({}, props, prefetchHandlers, {\n    ref: mergeRefs(forwardedRef, ref),\n    to: to\n  })), shouldPrefetch && !isAbsolute ? /*#__PURE__*/React.createElement(PrefetchPageLinks, {\n    page: href\n  }) : null);\n});\nNavLink.displayName = \"NavLink\";\n\n/**\n * This component renders an anchor tag and is the primary way the user will\n * navigate around your website.\n *\n * @see https://remix.run/components/link\n */\nlet Link = /*#__PURE__*/React.forwardRef(({\n  to,\n  prefetch = \"none\",\n  ...props\n}, forwardedRef) => {\n  let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to);\n  let href = useHref(to);\n  let [shouldPrefetch, ref, prefetchHandlers] = usePrefetchBehavior(prefetch, props);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Link$1, _extends({}, props, prefetchHandlers, {\n    ref: mergeRefs(forwardedRef, ref),\n    to: to\n  })), shouldPrefetch && !isAbsolute ? /*#__PURE__*/React.createElement(PrefetchPageLinks, {\n    page: href\n  }) : null);\n});\nLink.displayName = \"Link\";\nfunction composeEventHandlers(theirHandler, ourHandler) {\n  return event => {\n    theirHandler && theirHandler(event);\n    if (!event.defaultPrevented) {\n      ourHandler(event);\n    }\n  };\n}\n\n// Return the matches actively being displayed:\n// - In SPA Mode we only SSR/hydrate the root match, and include all matches\n//   after hydration. This lets the router handle initial match loads via lazy().\n// - When an error boundary is rendered, we slice off matches up to the\n//   boundary for <Links>/<Meta>\nfunction getActiveMatches(matches, errors, isSpaMode) {\n  if (isSpaMode && !isHydrated) {\n    return [matches[0]];\n  }\n  if (errors) {\n    let errorIdx = matches.findIndex(m => errors[m.route.id] !== undefined);\n    return matches.slice(0, errorIdx + 1);\n  }\n  return matches;\n}\n\n/**\n * Renders the `<link>` tags for the current routes.\n *\n * @see https://remix.run/components/links\n */\nfunction Links() {\n  let {\n    isSpaMode,\n    manifest,\n    routeModules,\n    criticalCss\n  } = useRemixContext();\n  let {\n    errors,\n    matches: routerMatches\n  } = useDataRouterStateContext();\n  let matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let keyedLinks = React.useMemo(() => getKeyedLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, criticalCss ? /*#__PURE__*/React.createElement(\"style\", {\n    dangerouslySetInnerHTML: {\n      __html: criticalCss\n    }\n  }) : null, keyedLinks.map(({\n    key,\n    link\n  }) => isPageLinkDescriptor(link) ? /*#__PURE__*/React.createElement(PrefetchPageLinks, _extends({\n    key: key\n  }, link)) : /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: key\n  }, link))));\n}\n\n/**\n * This component renders all the `<link rel=\"prefetch\">` and\n * `<link rel=\"modulepreload\"/>` tags for all the assets (data, modules, css) of\n * a given page.\n *\n * @param props\n * @param props.page\n * @see https://remix.run/components/prefetch-page-links\n */\nfunction PrefetchPageLinks({\n  page,\n  ...dataLinkProps\n}) {\n  let {\n    router\n  } = useDataRouterContext();\n  let matches = React.useMemo(() => matchRoutes(router.routes, page, router.basename), [router.routes, page, router.basename]);\n  if (!matches) {\n    console.warn(`Tried to prefetch ${page} but no routes matched.`);\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(PrefetchPageLinksImpl, _extends({\n    page: page,\n    matches: matches\n  }, dataLinkProps));\n}\nfunction useKeyedPrefetchLinks(matches) {\n  let {\n    manifest,\n    routeModules\n  } = useRemixContext();\n  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React.useState([]);\n  React.useEffect(() => {\n    let interrupted = false;\n    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(links => {\n      if (!interrupted) {\n        setKeyedPrefetchLinks(links);\n      }\n    });\n    return () => {\n      interrupted = true;\n    };\n  }, [matches, manifest, routeModules]);\n  return keyedPrefetchLinks;\n}\nfunction PrefetchPageLinksImpl({\n  page,\n  matches: nextMatches,\n  ...linkProps\n}) {\n  let location = useLocation();\n  let {\n    future,\n    manifest,\n    routeModules\n  } = useRemixContext();\n  let {\n    matches\n  } = useDataRouterStateContext();\n  let newMatchesForData = React.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"data\"), [page, nextMatches, matches, manifest, location]);\n  let newMatchesForAssets = React.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"assets\"), [page, nextMatches, matches, manifest, location]);\n  let dataHrefs = React.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);\n  let moduleHrefs = React.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);\n\n  // needs to be a hook with async behavior because we need the modules, not\n  // just the manifest like the other links in here.\n  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);\n  let linksToRender = null;\n  if (!future.unstable_singleFetch) {\n    // Non-single-fetch prefetching\n    linksToRender = dataHrefs.map(href => /*#__PURE__*/React.createElement(\"link\", _extends({\n      key: href,\n      rel: \"prefetch\",\n      as: \"fetch\",\n      href: href\n    }, linkProps)));\n  } else if (newMatchesForData.length > 0) {\n    // Single-fetch with routes that require data\n    let url = addRevalidationParam(manifest, routeModules, nextMatches.map(m => m.route), newMatchesForData.map(m => m.route), singleFetchUrl(page));\n    if (url.searchParams.get(\"_routes\") !== \"\") {\n      linksToRender = /*#__PURE__*/React.createElement(\"link\", _extends({\n        key: url.pathname + url.search,\n        rel: \"prefetch\",\n        as: \"fetch\",\n        href: url.pathname + url.search\n      }, linkProps));\n    }\n  } else ;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, linksToRender, moduleHrefs.map(href => /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: href,\n    rel: \"modulepreload\",\n    href: href\n  }, linkProps))), keyedPrefetchLinks.map(({\n    key,\n    link\n  }) =>\n  /*#__PURE__*/\n  // these don't spread `linkProps` because they are full link descriptors\n  // already with their own props\n  React.createElement(\"link\", _extends({\n    key: key\n  }, link))));\n}\n\n/**\n * Renders HTML tags related to metadata for the current route.\n *\n * @see https://remix.run/components/meta\n */\nfunction Meta() {\n  let {\n    isSpaMode,\n    routeModules\n  } = useRemixContext();\n  let {\n    errors,\n    matches: routerMatches,\n    loaderData\n  } = useDataRouterStateContext();\n  let location = useLocation();\n  let _matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let error = null;\n  if (errors) {\n    error = errors[_matches[_matches.length - 1].route.id];\n  }\n  let meta = [];\n  let leafMeta = null;\n  let matches = [];\n  for (let i = 0; i < _matches.length; i++) {\n    let _match = _matches[i];\n    let routeId = _match.route.id;\n    let data = loaderData[routeId];\n    let params = _match.params;\n    let routeModule = routeModules[routeId];\n    let routeMeta = [];\n    let match = {\n      id: routeId,\n      data,\n      meta: [],\n      params: _match.params,\n      pathname: _match.pathname,\n      handle: _match.route.handle,\n      error\n    };\n    matches[i] = match;\n    if (routeModule !== null && routeModule !== void 0 && routeModule.meta) {\n      routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n        data,\n        params,\n        location,\n        matches,\n        error\n      }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;\n    } else if (leafMeta) {\n      // We only assign the route's meta to the nearest leaf if there is no meta\n      // export in the route. The meta function may return a falsy value which\n      // is effectively the same as an empty array.\n      routeMeta = [...leafMeta];\n    }\n    routeMeta = routeMeta || [];\n    if (!Array.isArray(routeMeta)) {\n      throw new Error(\"The route at \" + _match.route.path + \" returns an invalid value. All route meta functions must \" + \"return an array of meta objects.\" + \"\\n\\nTo reference the meta function API, see https://remix.run/route/meta\");\n    }\n    match.meta = routeMeta;\n    matches[i] = match;\n    meta = [...routeMeta];\n    leafMeta = meta;\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, meta.flat().map(metaProps => {\n    if (!metaProps) {\n      return null;\n    }\n    if (\"tagName\" in metaProps) {\n      let {\n        tagName,\n        ...rest\n      } = metaProps;\n      if (!isValidMetaTag(tagName)) {\n        console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`);\n        return null;\n      }\n      let Comp = tagName;\n      return /*#__PURE__*/React.createElement(Comp, _extends({\n        key: JSON.stringify(rest)\n      }, rest));\n    }\n    if (\"title\" in metaProps) {\n      return /*#__PURE__*/React.createElement(\"title\", {\n        key: \"title\"\n      }, String(metaProps.title));\n    }\n    if (\"charset\" in metaProps) {\n      metaProps.charSet ??= metaProps.charset;\n      delete metaProps.charset;\n    }\n    if (\"charSet\" in metaProps && metaProps.charSet != null) {\n      return typeof metaProps.charSet === \"string\" ? /*#__PURE__*/React.createElement(\"meta\", {\n        key: \"charSet\",\n        charSet: metaProps.charSet\n      }) : null;\n    }\n    if (\"script:ld+json\" in metaProps) {\n      try {\n        let json = JSON.stringify(metaProps[\"script:ld+json\"]);\n        return /*#__PURE__*/React.createElement(\"script\", {\n          key: `script:ld+json:${json}`,\n          type: \"application/ld+json\",\n          dangerouslySetInnerHTML: {\n            __html: json\n          }\n        });\n      } catch (err) {\n        return null;\n      }\n    }\n    return /*#__PURE__*/React.createElement(\"meta\", _extends({\n      key: JSON.stringify(metaProps)\n    }, metaProps));\n  }));\n}\nfunction isValidMetaTag(tagName) {\n  return typeof tagName === \"string\" && /^(meta|link)$/.test(tagName);\n}\nfunction Await(props) {\n  return /*#__PURE__*/React.createElement(Await$1, props);\n}\n\n/**\n * Tracks whether Remix has finished hydrating or not, so scripts can be skipped\n * during client-side updates.\n */\nlet isHydrated = false;\n/**\n * Renders the `<script>` tags needed for the initial render. Bundles for\n * additional routes are loaded later as needed.\n *\n * @param props Additional properties to add to each script tag that is rendered.\n * In addition to scripts, \\<link rel=\"modulepreload\"> tags receive the crossOrigin\n * property if provided.\n *\n * @see https://remix.run/components/scripts\n */\nfunction Scripts(props) {\n  let {\n    manifest,\n    serverHandoffString,\n    abortDelay,\n    serializeError,\n    isSpaMode,\n    future,\n    renderMeta\n  } = useRemixContext();\n  let {\n    router,\n    static: isStatic,\n    staticContext\n  } = useDataRouterContext();\n  let {\n    matches: routerMatches\n  } = useDataRouterStateContext();\n  let navigation = useNavigation();\n\n  // Let <RemixServer> know that we hydrated and we should render the single\n  // fetch streaming scripts\n  if (renderMeta) {\n    renderMeta.didRenderScripts = true;\n  }\n  let matches = getActiveMatches(routerMatches, null, isSpaMode);\n  React.useEffect(() => {\n    isHydrated = true;\n  }, []);\n  let serializePreResolvedErrorImp = (key, error) => {\n    let toSerialize;\n    if (serializeError && error instanceof Error) {\n      toSerialize = serializeError(error);\n    } else {\n      toSerialize = error;\n    }\n    return `${JSON.stringify(key)}:__remixContext.p(!1, ${escapeHtml(JSON.stringify(toSerialize))})`;\n  };\n  let serializePreresolvedDataImp = (routeId, key, data) => {\n    let serializedData;\n    try {\n      serializedData = JSON.stringify(data);\n    } catch (error) {\n      return serializePreResolvedErrorImp(key, error);\n    }\n    return `${JSON.stringify(key)}:__remixContext.p(${escapeHtml(serializedData)})`;\n  };\n  let serializeErrorImp = (routeId, key, error) => {\n    let toSerialize;\n    if (serializeError && error instanceof Error) {\n      toSerialize = serializeError(error);\n    } else {\n      toSerialize = error;\n    }\n    return `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(key)}, !1, ${escapeHtml(JSON.stringify(toSerialize))})`;\n  };\n  let serializeDataImp = (routeId, key, data) => {\n    let serializedData;\n    try {\n      serializedData = JSON.stringify(data);\n    } catch (error) {\n      return serializeErrorImp(routeId, key, error);\n    }\n    return `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(key)}, ${escapeHtml(serializedData)})`;\n  };\n  let deferredScripts = [];\n  let initialScripts = React.useMemo(() => {\n    var _manifest$hmr;\n    let streamScript = future.unstable_singleFetch ?\n    // prettier-ignore\n    \"window.__remixContext.stream = new ReadableStream({\" + \"start(controller){\" + \"window.__remixContext.streamController = controller;\" + \"}\" + \"}).pipeThrough(new TextEncoderStream());\" : \"\";\n    let contextScript = staticContext ? `window.__remixContext = ${serverHandoffString};${streamScript}` : \" \";\n\n    // When single fetch is enabled, deferred is handled by turbo-stream\n    let activeDeferreds = future.unstable_singleFetch ? undefined : staticContext === null || staticContext === void 0 ? void 0 : staticContext.activeDeferreds;\n\n    // This sets up the __remixContext with utility functions used by the\n    // deferred scripts.\n    // - __remixContext.p is a function that takes a resolved value or error and returns a promise.\n    //   This is used for transmitting pre-resolved promises from the server to the client.\n    // - __remixContext.n is a function that takes a routeID and key to returns a promise for later\n    //   resolution by the subsequently streamed chunks.\n    // - __remixContext.r is a function that takes a routeID, key and value or error and resolves\n    //   the promise created by __remixContext.n.\n    // - __remixContext.t is a map or routeId to keys to an object containing `e` and `r` methods\n    //   to resolve or reject the promise created by __remixContext.n.\n    // - __remixContext.a is the active number of deferred scripts that should be rendered to match\n    //   the SSR tree for hydration on the client.\n    contextScript += !activeDeferreds ? \"\" : [\"__remixContext.p = function(v,e,p,x) {\", \"  if (typeof e !== 'undefined') {\", process.env.NODE_ENV === \"development\" ? \"    x=new Error(e.message);\\n    x.stack=e.stack;\" : '    x=new Error(\"Unexpected Server Error\");\\n    x.stack=undefined;', \"    p=Promise.reject(x);\", \"  } else {\", \"    p=Promise.resolve(v);\", \"  }\", \"  return p;\", \"};\", \"__remixContext.n = function(i,k) {\", \"  __remixContext.t = __remixContext.t || {};\", \"  __remixContext.t[i] = __remixContext.t[i] || {};\", \"  let p = new Promise((r, e) => {__remixContext.t[i][k] = {r:(v)=>{r(v);},e:(v)=>{e(v);}};});\", typeof abortDelay === \"number\" ? `setTimeout(() => {if(typeof p._error !== \"undefined\" || typeof p._data !== \"undefined\"){return;} __remixContext.t[i][k].e(new Error(\"Server timeout.\"))}, ${abortDelay});` : \"\", \"  return p;\", \"};\", \"__remixContext.r = function(i,k,v,e,p,x) {\", \"  p = __remixContext.t[i][k];\", \"  if (typeof e !== 'undefined') {\", process.env.NODE_ENV === \"development\" ? \"    x=new Error(e.message);\\n    x.stack=e.stack;\" : '    x=new Error(\"Unexpected Server Error\");\\n    x.stack=undefined;', \"    p.e(x);\", \"  } else {\", \"    p.r(v);\", \"  }\", \"};\"].join(\"\\n\") + Object.entries(activeDeferreds).map(([routeId, deferredData]) => {\n      let pendingKeys = new Set(deferredData.pendingKeys);\n      let promiseKeyValues = deferredData.deferredKeys.map(key => {\n        if (pendingKeys.has(key)) {\n          deferredScripts.push( /*#__PURE__*/React.createElement(DeferredHydrationScript, {\n            key: `${routeId} | ${key}`,\n            deferredData: deferredData,\n            routeId: routeId,\n            dataKey: key,\n            scriptProps: props,\n            serializeData: serializeDataImp,\n            serializeError: serializeErrorImp\n          }));\n          return `${JSON.stringify(key)}:__remixContext.n(${JSON.stringify(routeId)}, ${JSON.stringify(key)})`;\n        } else {\n          let trackedPromise = deferredData.data[key];\n          if (typeof trackedPromise._error !== \"undefined\") {\n            return serializePreResolvedErrorImp(key, trackedPromise._error);\n          } else {\n            return serializePreresolvedDataImp(routeId, key, trackedPromise._data);\n          }\n        }\n      }).join(\",\\n\");\n      return `Object.assign(__remixContext.state.loaderData[${JSON.stringify(routeId)}], {${promiseKeyValues}});`;\n    }).join(\"\\n\") + (deferredScripts.length > 0 ? `__remixContext.a=${deferredScripts.length};` : \"\");\n    let routeModulesScript = !isStatic ? \" \" : `${(_manifest$hmr = manifest.hmr) !== null && _manifest$hmr !== void 0 && _manifest$hmr.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : \"\"}import ${JSON.stringify(manifest.url)};\n${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(\"\\n\")}\nwindow.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: createHtml(contextScript),\n      type: undefined\n    })), /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: createHtml(routeModulesScript),\n      type: \"module\",\n      async: true\n    })));\n    // disabled deps array because we are purposefully only rendering this once\n    // for hydration, after that we want to just continue rendering the initial\n    // scripts as they were when the page first loaded\n    // eslint-disable-next-line\n  }, []);\n  if (!isStatic && typeof __remixContext === \"object\" && __remixContext.a) {\n    for (let i = 0; i < __remixContext.a; i++) {\n      deferredScripts.push( /*#__PURE__*/React.createElement(DeferredHydrationScript, {\n        key: i,\n        scriptProps: props,\n        serializeData: serializeDataImp,\n        serializeError: serializeErrorImp\n      }));\n    }\n  }\n\n  // avoid waterfall when importing the next route module\n  let nextMatches = React.useMemo(() => {\n    if (navigation.location) {\n      // FIXME: can probably use transitionManager `nextMatches`\n      let matches = matchRoutes(router.routes, navigation.location, router.basename);\n      invariant(matches, `No routes match path \"${navigation.location.pathname}\"`);\n      return matches;\n    }\n    return [];\n  }, [navigation.location, router.routes, router.basename]);\n  let routePreloads = matches.concat(nextMatches).map(match => {\n    let route = manifest.routes[match.route.id];\n    return (route.imports || []).concat([route.module]);\n  }).flat(1);\n  let preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);\n  return isHydrated ? null : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"link\", {\n    rel: \"modulepreload\",\n    href: manifest.url,\n    crossOrigin: props.crossOrigin\n  }), /*#__PURE__*/React.createElement(\"link\", {\n    rel: \"modulepreload\",\n    href: manifest.entry.module,\n    crossOrigin: props.crossOrigin\n  }), dedupe(preloads).map(path => /*#__PURE__*/React.createElement(\"link\", {\n    key: path,\n    rel: \"modulepreload\",\n    href: path,\n    crossOrigin: props.crossOrigin\n  })), initialScripts, deferredScripts);\n}\nfunction DeferredHydrationScript({\n  dataKey,\n  deferredData,\n  routeId,\n  scriptProps,\n  serializeData,\n  serializeError\n}) {\n  if (typeof document === \"undefined\" && deferredData && dataKey && routeId) {\n    invariant(deferredData.pendingKeys.includes(dataKey), `Deferred data for route ${routeId} with key ${dataKey} was not pending but tried to render a script for it.`);\n  }\n  return /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback:\n    // This makes absolutely no sense. The server renders null as a fallback,\n    // but when hydrating, we need to render a script tag to avoid a hydration issue.\n    // To reproduce a hydration mismatch, just render null as a fallback.\n    typeof document === \"undefined\" && deferredData && dataKey && routeId ? null : /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n      async: true,\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: {\n        __html: \" \"\n      }\n    }))\n  }, typeof document === \"undefined\" && deferredData && dataKey && routeId ? /*#__PURE__*/React.createElement(Await, {\n    resolve: deferredData.data[dataKey],\n    errorElement: /*#__PURE__*/React.createElement(ErrorDeferredHydrationScript, {\n      dataKey: dataKey,\n      routeId: routeId,\n      scriptProps: scriptProps,\n      serializeError: serializeError\n    }),\n    children: data => {\n      return /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n        async: true,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: {\n          __html: serializeData(routeId, dataKey, data)\n        }\n      }));\n    }\n  }) : /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n    async: true,\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: \" \"\n    }\n  })));\n}\nfunction ErrorDeferredHydrationScript({\n  dataKey,\n  routeId,\n  scriptProps,\n  serializeError\n}) {\n  let error = useAsyncError();\n  return /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: serializeError(routeId, dataKey, error)\n    }\n  }));\n}\nfunction dedupe(array) {\n  return [...new Set(array)];\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n *\n * @see https://remix.run/hooks/use-matches\n */\nfunction useMatches() {\n  return useMatches$1();\n}\n\n/**\n * Returns the JSON parsed data from the current route's `loader`.\n *\n * @see https://remix.run/hooks/use-loader-data\n */\nfunction useLoaderData() {\n  return useLoaderData$1();\n}\n\n/**\n * Returns the loaderData for the given routeId.\n *\n * @see https://remix.run/hooks/use-route-loader-data\n */\nfunction useRouteLoaderData(routeId) {\n  return useRouteLoaderData$1(routeId);\n}\n\n/**\n * Returns the JSON parsed data from the current route's `action`.\n *\n * @see https://remix.run/hooks/use-action-data\n */\nfunction useActionData() {\n  return useActionData$1();\n}\n\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n *\n * @see https://remix.run/hooks/use-fetcher\n */\nfunction useFetcher(opts = {}) {\n  return useFetcher$1(opts);\n}\n\n/**\n * This component connects your app to the Remix asset server and\n * automatically reloads the page when files change in development.\n * In production, it renders null, so you can safely render it always in your root route.\n *\n * @see https://remix.run/docs/components/live-reload\n */\nconst LiveReload =\n// Dead Code Elimination magic for production builds.\n// This way devs don't have to worry about doing the NODE_ENV check themselves.\nprocess.env.NODE_ENV !== \"development\" ? () => null : function LiveReload({\n  origin,\n  port,\n  timeoutMs = 1000,\n  nonce = undefined\n}) {\n  // @ts-expect-error\n  let isViteClient = import.meta && import.meta.env !== undefined;\n  if (isViteClient) {\n    console.warn([\"`<LiveReload />` is obsolete when using Vite and can conflict with Vite's built-in HMR runtime.\", \"\", \"Remove `<LiveReload />` from your code and instead only use `<Scripts />`.\", \"Then refresh the page to remove lingering scripts from `<LiveReload />`.\"].join(\"\\n\"));\n    return null;\n  }\n  origin ??= process.env.REMIX_DEV_ORIGIN;\n  let js = String.raw;\n  return /*#__PURE__*/React.createElement(\"script\", {\n    nonce: nonce,\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: js`\n                function remixLiveReloadConnect(config) {\n                  let LIVE_RELOAD_ORIGIN = ${JSON.stringify(origin)};\n                  let protocol =\n                    LIVE_RELOAD_ORIGIN ? new URL(LIVE_RELOAD_ORIGIN).protocol.replace(/^http/, \"ws\") :\n                    location.protocol === \"https:\" ? \"wss:\" : \"ws:\"; // remove in v2?\n                  let hostname = LIVE_RELOAD_ORIGIN ? new URL(LIVE_RELOAD_ORIGIN).hostname : location.hostname;\n                  let url = new URL(protocol + \"//\" + hostname + \"/socket\");\n\n                  url.port =\n                    ${port} ||\n                    (LIVE_RELOAD_ORIGIN ? new URL(LIVE_RELOAD_ORIGIN).port : 8002);\n\n                  let ws = new WebSocket(url.href);\n                  ws.onmessage = async (message) => {\n                    let event = JSON.parse(message.data);\n                    if (event.type === \"LOG\") {\n                      console.log(event.message);\n                    }\n                    if (event.type === \"RELOAD\") {\n                      console.log(\" Reloading window ...\");\n                      window.location.reload();\n                    }\n                    if (event.type === \"HMR\") {\n                      if (!window.__hmr__ || !window.__hmr__.contexts) {\n                        console.log(\" [HMR] No HMR context, reloading window ...\");\n                        window.location.reload();\n                        return;\n                      }\n                      if (!event.updates || !event.updates.length) return;\n                      let updateAccepted = false;\n                      let needsRevalidation = new Set();\n                      for (let update of event.updates) {\n                        console.log(\"[HMR] \" + update.reason + \" [\" + update.id +\"]\")\n                        if (update.revalidate) {\n                          needsRevalidation.add(update.routeId);\n                          console.log(\"[HMR] Revalidating [\" + update.routeId + \"]\");\n                        }\n                        let imported = await import(update.url +  '?t=' + event.assetsManifest.hmr.timestamp);\n                        if (window.__hmr__.contexts[update.id]) {\n                          let accepted = window.__hmr__.contexts[update.id].emit(\n                            imported\n                          );\n                          if (accepted) {\n                            console.log(\"[HMR] Update accepted by\", update.id);\n                            updateAccepted = true;\n                          }\n                        }\n                      }\n                      if (event.assetsManifest && window.__hmr__.contexts[\"remix:manifest\"]) {\n                        let accepted = window.__hmr__.contexts[\"remix:manifest\"].emit(\n                          { needsRevalidation, assetsManifest: event.assetsManifest }\n                        );\n                        if (accepted) {\n                          console.log(\"[HMR] Update accepted by\", \"remix:manifest\");\n                          updateAccepted = true;\n                        }\n                      }\n                      if (!updateAccepted) {\n                        console.log(\"[HMR] Update rejected, reloading...\");\n                        window.location.reload();\n                      }\n                    }\n                  };\n                  ws.onopen = () => {\n                    if (config && typeof config.onOpen === \"function\") {\n                      config.onOpen();\n                    }\n                  };\n                  ws.onclose = (event) => {\n                    if (event.code === 1006) {\n                      console.log(\"Remix dev asset server web socket closed. Reconnecting...\");\n                      setTimeout(\n                        () =>\n                          remixLiveReloadConnect({\n                            onOpen: () => window.location.reload(),\n                          }),\n                      ${String(timeoutMs)}\n                      );\n                    }\n                  };\n                  ws.onerror = (error) => {\n                    console.log(\"Remix dev asset server web socket error:\");\n                    console.error(error);\n                  };\n                }\n                remixLiveReloadConnect();\n              `\n    }\n  });\n};\nfunction mergeRefs(...refs) {\n  return value => {\n    refs.forEach(ref => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\nexport { Await, Link, Links, LiveReload, Meta, NavLink, PrefetchPageLinks, RemixContext, Scripts, composeEventHandlers, useActionData, useFetcher, useLoaderData, useMatches, useRemixContext, useRouteLoaderData };\n"],"names":["_extends","target","i","source","key","_objectWithoutPropertiesLoose","excluded","sourceKeys","isModifiedEvent","event","shouldProcessLinkClick","_excluded","_excluded2","REACT_ROUTER_VERSION","ViewTransitionContext","FetchersContext","React.createContext","START_TRANSITION","startTransitionImpl","React","FLUSH_SYNC","flushSyncImpl","ReactDOM","startTransitionSafe","cb","flushSyncSafe","Deferred$1","resolve","reject","value","reason","RouterProvider","_ref","fallbackElement","router","future","state","setStateImpl","React.useState","pendingState","setPendingState","vtContext","setVtContext","renderDfd","setRenderDfd","transition","setTransition","interruption","setInterruption","fetcherData","React.useRef","v7_startTransition","optInStartTransition","React.useCallback","setState","newState","_ref2","deletedFetchers","flushSync","viewTransitionOpts","fetcher","isViewTransitionUnavailable","t","React.useLayoutEffect","React.useEffect","Deferred","renderPromise","navigator","React.useMemo","n","to","opts","basename","dataRouterContext","React.createElement","React.Fragment","UNSAFE_DataRouterContext","UNSAFE_DataRouterStateContext","Router","DataRoutes","_ref3","routes","UNSAFE_useRoutesImpl","isBrowser","ABSOLUTE_URL_REGEX","Link","React.forwardRef","_ref7","ref","onClick","relative","reloadDocument","replace","preventScrollReset","unstable_viewTransition","rest","React.useContext","UNSAFE_NavigationContext","absoluteHref","isExternal","currentUrl","targetUrl","path","stripBasename","href","useHref","internalOnClick","useLinkClickHandler","handleClick","NavLink","_ref8","ariaCurrentProp","caseSensitive","classNameProp","end","styleProp","children","useResolvedPath","location","useLocation","routerState","isTransitioning","useViewTransitionState","toPathname","locationPathname","nextLocationPathname","endSlashPosition","isActive","isPending","renderProps","ariaCurrent","className","style","DataRouterHook","DataRouterStateHook","useDataRouterContext","hookName","ctx","UNSAFE_invariant","useDataRouterState","_temp","replaceProp","navigate","useNavigate","createPath","SCROLL_RESTORATION_STORAGE_KEY","savedScrollPositions","useScrollRestoration","_temp4","getKey","storageKey","restoreScrollPosition","matches","useMatches","navigation","useNavigation","usePageHide","sessionPositions","getKeyWithoutBasename","disableScrollRestoration","el","callback","options","capture","currentPath","nextPath","matchPath","HOLE","NAN","NEGATIVE_INFINITY","NEGATIVE_ZERO","NULL","POSITIVE_INFINITY","UNDEFINED","TYPE_BIGINT","TYPE_DATE","TYPE_ERROR","TYPE_MAP","TYPE_NULL_OBJECT","TYPE_PROMISE","TYPE_REGEXP","TYPE_SET","TYPE_SYMBOL","TYPE_URL","TYPE_PREVIOUS_RESOLVED","createLineSplittingTransform","decoder","leftover","chunk","controller","str","parts","part","globalObj","unflatten","parsed","hydrated","values","hydrate","startIndex","index","deferred","plugins","type","b","c","set","map","obj","d","message","errorType","error","args","plugin","result","array","object","decode","readable","done","reader","decoded","decodeInitial","donePromise","decodeDeferred","read","line","colonIndex","deferredId","lineData","jsonLine","SingleFetchRedirectSymbol","invariant","loadRouteModule","route","routeModulesCache","routeModule","getKeyedLinksForMatches","routeModules","manifest","descriptors","match","_module$links","module","preloads","getCurrentPageModulePreloadHrefs","dedupeLinkDescriptors","prefetchStyleLinks","_route$css","_routeModule$links","isPreloadSupported","styleLinks","descriptor","isPageLinkDescriptor","matchingLinks","link","prefetchStyleLink","removeLink","isHtmlLinkDescriptor","getKeyedPrefetchLinks","links","mod","getNewMatchesForLinks","page","nextMatches","currentMatches","mode","parsePathPatch","isNew","matchPathChanged","_currentMatches$index","_currentMatches$","routeChoice","manifestRoute","getDataLinkHrefs","dedupeHrefs","pathname","search","searchParams","getModuleLinkHrefs","manifestPatch","hrefs","sortKeys","sorted","keys","preloadsSet","deduped","parsePath","_isPreloadSupported","ESCAPE_LOOKUP","ESCAPE_REGEX","escapeHtml","html","createHtml","isCatchResponse","response","isErrorResponse","isNetworkErrorResponse","isResponse","isRedirectResponse","isDeferredResponse","_response$headers$get","isDeferredData","fetchData","request","routeId","retry","url","init","createRequestInit","revalidation","data","text","contentType","DEFERRED_VALUE_PLACEHOLDER_PREFIX","parseDeferredReadableStream","stream","deferredData","deferredResolvers","sectionReader","readStreamSections","initialSection","criticalData","eventKey","section","sectionDataStrings","sectionDataString","err","resolver","AbortedDeferredError","UNSAFE_DeferredData","buffer","sections","closed","encoder","readStreamSection","splitSections","mergeArrays","s","arrays","out","total","arr","offset","getSingleFetchDataStrategy","singleFetchActionStrategy","singleFetchLoaderStrategy","m","actionStatus","handler","singleFetchUrl","status","fetchAndDecode","unwrapSingleFetchResult","singleFetchPromise","stripIndexParam","unwrapSingleFetchResults","addRevalidationParam","results","indexValues","indexValuesToKeep","indexValue","toKeep","matchedRoutes","loadRoutes","genRouteIds","id","r","_routeModules$r$id","_manifest$routes$r$id","matchedIds","loadIds","_manifest$routes$r$id2","reqUrl","res","decodeViaTurboStream","e","body","global","name","stack","Constructor","statusText","UNSAFE_ErrorResponseImpl","UNSAFE_SingleFetchRedirectSymbol","redirect","headers","context","useDataRouterStateContext","RemixContext","useRemixContext","usePrefetchBehavior","prefetch","theirElementProps","maybePrefetch","setMaybePrefetch","shouldPrefetch","setShouldPrefetch","onFocus","onBlur","onMouseEnter","onMouseLeave","onTouchStart","entries","entry","observer","setIntent","cancelIntent","composeEventHandlers","props","forwardedRef","isAbsolute","prefetchHandlers","NavLink$1","mergeRefs","PrefetchPageLinks","Link$1","theirHandler","ourHandler","getActiveMatches","errors","isSpaMode","isHydrated","errorIdx","Links","criticalCss","routerMatches","keyedLinks","dataLinkProps","matchRoutes","PrefetchPageLinksImpl","useKeyedPrefetchLinks","keyedPrefetchLinks","setKeyedPrefetchLinks","interrupted","linkProps","newMatchesForData","newMatchesForAssets","dataHrefs","moduleHrefs","linksToRender","Meta","loaderData","_matches","meta","leafMeta","_match","params","routeMeta","metaProps","tagName","isValidMetaTag","Comp","json","Await","Await$1","Scripts","serverHandoffString","abortDelay","serializeError","renderMeta","isStatic","staticContext","serializePreResolvedErrorImp","toSerialize","serializePreresolvedDataImp","serializedData","serializeErrorImp","serializeDataImp","deferredScripts","initialScripts","_manifest$hmr","streamScript","contextScript","activeDeferreds","pendingKeys","promiseKeyValues","DeferredHydrationScript","trackedPromise","routeModulesScript","routePreloads","dedupe","dataKey","scriptProps","serializeData","React.Suspense","ErrorDeferredHydrationScript","useAsyncError","refs"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}